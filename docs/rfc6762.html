<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.11.dev">
<title>RFC 6762</title>
<style>
@import url(https://fonts.googleapis.com/css?family=Varela+Round|Open+Sans:400italic,600italic,400,600|Ubuntu+Mono:400);
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: #fefdfd; color: rgba(0, 0, 0, 0.8); padding: 0; margin: 0; font-family: "Open Sans", sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.stretch { width: 100%; }

p.lead { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.25; color: #002c5e; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #005580; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #078d71; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.5; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Varela Round", sans-serif; font-weight: 400; font-style: normal; color: #00326b; text-rendering: optimizeLegibility; margin-top: 0.8em; margin-bottom: 0.5em; line-height: 1.0625em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #057aff; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid rgba(145, 135, 84, 0.15); border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Ubuntu Mono", "Inconsolata", monospace; font-weight: 400; color: #331d00; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.5; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #666666; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #666666; }

blockquote, blockquote p { line-height: 1.5; color: #999999; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.25; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px rgba(145, 135, 84, 0.15); }
table thead, table tfoot { background: rgba(119, 84, 22, 0.1); font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: rgba(119, 84, 22, 0.025); }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.5; }

body { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.25; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

:not(pre):not([class^=L]) > code { font-size: 1.0625em; font-style: normal !important; letter-spacing: 0; padding: 0; line-height: 1.25; word-wrap: break-word; }

:not(pre) > code.nobreak { word-wrap: normal; }
:not(pre) > code.nowrap { white-space: nowrap; }

pre { color: inherit; font-family: "Liberation Mono", "Consolas", monospace; line-height: 1.4; }
pre code, pre pre { color: inherit; font-size: inherit; line-height: inherit; }
pre > code { display: block; }

pre.nowrap, pre.nowrap pre { white-space: pre; word-wrap: normal; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { font-family: "Ubuntu Mono", "Inconsolata", monospace; display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menuref { color: #000; }

.menuseq b:not(.caret), .menuref { font-weight: inherit; }

.menuseq { word-spacing: -0.02em; }
.menuseq b.caret { font-size: 1.25em; line-height: 0.8; }
.menuseq i.caret { font-weight: bold; text-align: center; width: 0.45em; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: #1a0f00; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: #703f1c; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid rgba(145, 135, 84, 0.15); }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid rgba(145, 135, 84, 0.15); padding-bottom: 8px; }
#header .details { border-bottom: 1px solid rgba(145, 135, 84, 0.15); line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #666666; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #999999; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #999999; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: #703f1c; border-bottom: 1px solid rgba(145, 135, 84, 0.15); padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 0px solid #dddddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Varela Round", sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #002c5e; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background: #f2f2f4; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #dddddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #dddddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d6d6dd; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f4; -webkit-border-radius: 6px; border-radius: 6px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background: #0b445a; padding: 1.25em; }

#footer-text { color: #fefdfd; line-height: 1.35; }

#content { margin-bottom: 0.625em; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { #content { margin-bottom: 1.25em; }
  .sect1 { padding-bottom: 1.25em; } }
.sect1:last-child { padding-bottom: 0; }

.sect1 + .sect1 { border-top: 0px solid #dddddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #00326b; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #002652; }

details, .audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

details > summary:first-of-type { cursor: pointer; display: list-item; outline: none; margin-bottom: 0.75em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock.fit-content > caption.title { white-space: nowrap; width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > [class="paragraph"]:first-of-type p { font-size: 1.21875em; line-height: 1.6; color: #703f1c; }

table.tableblock #preamble > .sectionbody > [class="paragraph"]:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Varela Round", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid rgba(145, 135, 84, 0.15); color: #666666; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #eddbdb; margin-bottom: 1.25em; padding: 1.25em; background: #fefdfd; -webkit-border-radius: 6px; border-radius: 6px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #d1d1d8; margin-bottom: 1.25em; padding: 1.25em; background: #ececef; -webkit-border-radius: 6px; border-radius: 6px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #002c5e; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock > .content > pre { border: 1px solid rgba(16, 195, 196, 0.125); -webkit-border-radius: 6px; border-radius: 6px; word-wrap: break-word; overflow-x: auto; padding: 1em; font-size: 0.8125em; }
@media only screen and (min-width: 768px) { .literalblock pre, .listingblock > .content > pre { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .listingblock > .content > pre { font-size: 1em; } }

.literalblock pre, .listingblock > .content > pre:not(.highlight), .listingblock > .content > pre[class="highlight"], .listingblock > .content > pre[class^="highlight "] { background: rgba(16, 195, 196, 0.05); }

.literalblock.output pre { color: rgba(16, 195, 196, 0.05); background-color: inherit; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: inherit; opacity: 0.5; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: inherit; opacity: 0.5; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 6px; border-radius: 6px; }

.prettyprint { background: rgba(16, 195, 196, 0.05); }

pre.prettyprint .linenums { line-height: 1.4; margin-left: 2em; }

pre.prettyprint li { background: none; list-style-type: inherit; padding-left: 0; }

pre.prettyprint li code[data-lang]:before { opacity: 1; }

pre.prettyprint li:not(:first-child) code[data-lang]:before { display: none; }

table.linenotable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }
table.linenotable td[class] { color: inherit; vertical-align: top; padding: 0; line-height: inherit; white-space: normal; }
table.linenotable td.code { padding-left: 0.75em; }
table.linenotable td.linenos { border-right: 1px solid currentColor; opacity: 0.35; padding-right: 0.5em; }

pre.pygments .lineno { border-right: 1px solid currentColor; opacity: 0.35; display: inline-block; margin-right: 0.75em; }
pre.pygments .lineno:before { content: ""; margin-right: -0.125em; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock:not(.excerpt) > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock p { color: #999999; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #002c5e; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.75em; margin-right: 0.5ex; text-align: right; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #999999; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.8125em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: #666666; }

.quoteblock.abstract blockquote:before, .quoteblock.excerpt blockquote:before, .quoteblock .quoteblock blockquote:before { display: none; }
.quoteblock.abstract blockquote, .quoteblock.abstract p, .quoteblock.excerpt blockquote, .quoteblock.excerpt p, .quoteblock .quoteblock blockquote, .quoteblock .quoteblock p { line-height: 1.6; word-spacing: 0; }
.quoteblock.abstract { margin: 0 1em 1.25em 1em; display: block; }
.quoteblock.abstract > .title { margin: 0 0 0.375em 0; font-size: 1.15em; text-align: center; }
.quoteblock.excerpt > blockquote, .quoteblock .quoteblock { padding: 0 0 0.25em 1em; border-left: 0.25em solid rgba(145, 135, 84, 0.15); }
.quoteblock.excerpt, .quoteblock .quoteblock { margin-left: 0; }
.quoteblock.excerpt blockquote, .quoteblock.excerpt p, .quoteblock .quoteblock blockquote, .quoteblock .quoteblock p { color: inherit; font-size: 1.0625rem; }
.quoteblock.excerpt .attribution, .quoteblock .quoteblock .attribution { color: inherit; text-align: left; margin-right: 0; }

table.tableblock { max-width: 100%; border-collapse: separate; }

p.tableblock:last-child { margin-bottom: 0; }

td.tableblock > .content > :last-child { margin-bottom: -1.25em; }
td.tableblock > .content > :last-child.sidebarblock { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid rgba(145, 135, 84, 0.15); }

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock { border-width: 0 1px 1px 0; }

table.grid-all > tfoot > tr > .tableblock { border-width: 1px 1px 0 0; }

table.grid-cols > * > tr > .tableblock { border-width: 0 1px 0 0; }

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock { border-width: 0 0 1px 0; }

table.grid-rows > tfoot > tr > .tableblock { border-width: 1px 0 0 0; }

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock { border-bottom-width: 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot, table.frame-ends { border-width: 1px 0; }

table.stripes-all tr, table.stripes-odd tr:nth-of-type(odd), table.stripes-even tr:nth-of-type(even), table.stripes-hover tr:hover { background: rgba(119, 84, 22, 0.025); }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.5; background: rgba(119, 84, 22, 0.1); }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled { list-style-type: none; }

ul.no-bullet, ol.no-bullet, ol.unnumbered { margin-left: 0.625em; }

ul.unstyled, ol.unstyled { margin-left: 0; }

ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1.25em; font-size: 0.8em; position: relative; bottom: 0.125em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.inline { display: -ms-flexbox; display: -webkit-box; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; list-style: none; margin: 0 0 0.625em -1.25em; }

ul.inline > li { margin-left: 1.25em; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 1.25em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist td:not([class]):first-child { padding: 0.4em 0.75em 0 0.75em; line-height: 1; vertical-align: top; }
.colist td:not([class]):first-child img { max-width: none; }
.colist td:not([class]):last-child { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; margin-left: -1.05em; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }
a span.icon > .fa { cursor: inherit; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #004060; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

.rfc-error pre, .listingblock pre { background: rgba(255, 187, 204, 0.4); border-color: #aaaaaa; }

.rfc-error-text { background-color: rgba(255, 187, 204, 0.4); }

#toc.toc2 ul ul { list-style-type: circle; padding-left: 2em; }

.sect1 { padding-bottom: 0 !important; margin-bottom: 2.5em; }

#header h1 { font-weight: bold; position: relative; left: -0.0625em; }

#content h2, #content h3, #content #toctitle, #content .sidebarblock > .content > .title, #content h4, #content h5, #content #toctitle { position: relative; left: -0.0625em; }
#content h2 { font-weight: bold; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: black; }

pre.pygments.highlight { background-color: rgba(16, 195, 196, 0.05); }

.pygments .tok-err { border: none !important; color: #800000 !important; }

.pygments .tok-c { color: #999 !important; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158925429-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158925429-1');
</script>

<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/cferdinandi/gumshoe@5/dist/gumshoe.polyfills.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-scrollTo/2.1.2/jquery.scrollTo.js"></script>
<script>
   jQuery(function () {
      var scrollspy = new Gumshoe('#toc li > a', {
         nested: false
      });
      document.addEventListener('gumshoeActivate', function (event) {
         jQuery('#toc')
            .stop()
            .scrollTo(event.detail.link, 500, {
               offset: {
                  top:  0 - jQuery('#toc').height() / 2,
                  left: 0,
               }
            });
      }, false);
   });
</script>

<style>
   #toc li.active > a {
      font-weight: bold;
      text-decoration: underline;
         <!-- font-style: italic; -->
   }

  #toc li a {
     display: inline-block;
  }
</style>

<div id="header">
   <div style="text-align:center"> <b> This isnâ€™t the official RFC, please refer to the IETF website for the official RFC. Errors & omissions excepted </b> </div>
</div>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>RFC 6762</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#_status_of_this_memo">Status of This Memo</a></li>
<li><a href="#_copyright_notice">Copyright Notice</a></li>
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_conventions_and_terminology_used_in_this_document">2. Conventions and Terminology Used in This Document</a></li>
<li><a href="#_multicast_dns_names">3. Multicast DNS Names</a></li>
<li><a href="#_reverse_address_mapping">4. Reverse Address Mapping</a></li>
<li><a href="#_querying">5. Querying</a>
<ul class="sectlevel2">
<li><a href="#_one_shot_multicast_dns_queries">5.1. One-Shot Multicast DNS Queries</a></li>
<li><a href="#_continuous_multicast_dns_querying">5.2. Continuous Multicast DNS Querying</a></li>
<li><a href="#_multiple_questions_per_query">5.3. Multiple Questions per Query</a></li>
<li><a href="#_questions_requesting_unicast_responses">5.4. Questions Requesting Unicast Responses</a></li>
<li><a href="#_direct_unicast_queries_to_port_5353">5.5. Direct Unicast Queries to Port 5353</a></li>
</ul>
</li>
<li><a href="#_responding">6. Responding</a>
<ul class="sectlevel2">
<li><a href="#_negative_responses">6.1. Negative Responses</a></li>
<li><a href="#_responding_to_address_queries">6.2. Responding to Address Queries</a></li>
<li><a href="#_responding_to_multiquestion_queries">6.3. Responding to Multiquestion Queries</a></li>
<li><a href="#_response_aggregation">6.4. Response Aggregation</a></li>
<li><a href="#_wildcard_queries_qtype_any_and_qclass_any">6.5. Wildcard Queries (qtype "ANY" and qclass "ANY")</a></li>
<li><a href="#_cooperating_multicast_dns_responders">6.6. Cooperating Multicast DNS Responders</a></li>
<li><a href="#_legacy_unicast_responses">6.7. Legacy Unicast Responses</a></li>
</ul>
</li>
<li><a href="#_traffic_reduction">7. Traffic Reduction</a>
<ul class="sectlevel2">
<li><a href="#_known_answer_suppression">7.1. Known-Answer Suppression</a></li>
<li><a href="#_multipacket_known_answer_suppression">7.2. Multipacket Known-Answer Suppression</a></li>
<li><a href="#_duplicate_question_suppression">7.3. Duplicate Question Suppression</a></li>
<li><a href="#_duplicate_answer_suppression">7.4. Duplicate Answer Suppression</a></li>
</ul>
</li>
<li><a href="#_probing_and_announcing_on_startup">8. Probing and Announcing on Startup</a>
<ul class="sectlevel2">
<li><a href="#_probing">8.1. Probing</a></li>
<li><a href="#_simultaneous_probe_tiebreaking">8.2. Simultaneous Probe Tiebreaking</a>
<ul class="sectlevel3">
<li><a href="#_simultaneous_probe_tiebreaking_for_multiple_records">8.2.1. Simultaneous Probe Tiebreaking for Multiple Records</a></li>
</ul>
</li>
<li><a href="#_announcing">8.3. Announcing</a></li>
<li><a href="#_updating">8.4. Updating</a></li>
</ul>
</li>
<li><a href="#_conflict_resolution">9. Conflict Resolution</a></li>
<li><a href="#_resource_record_ttl_values_and_cache_coherency">10. Resource Record TTL Values and Cache Coherency</a>
<ul class="sectlevel2">
<li><a href="#_goodbye_packets">10.1. Goodbye Packets</a></li>
<li><a href="#_announcements_to_flush_outdated_cache_entries">10.2. Announcements to Flush Outdated Cache Entries</a></li>
<li><a href="#_cache_flush_on_topology_change">10.3. Cache Flush on Topology change</a></li>
<li><a href="#_cache_flush_on_failure_indication">10.4. Cache Flush on Failure Indication</a></li>
<li><a href="#_passive_observation_of_failures_poof">10.5. Passive Observation Of Failures (POOF)</a></li>
</ul>
</li>
<li><a href="#_source_address_check">11. Source Address Check</a></li>
<li><a href="#_special_characteristics_of_multicast_dns_domains">12. Special Characteristics of Multicast DNS Domains</a></li>
<li><a href="#_enabling_and_disabling_multicast_dns">13. Enabling and Disabling Multicast DNS</a></li>
<li><a href="#_considerations_for_multiple_interfaces">14. Considerations for Multiple Interfaces</a></li>
<li><a href="#_considerations_for_multiple_responders_on_the_same_machine">15. Considerations for Multiple Responders on the Same Machine</a>
<ul class="sectlevel2">
<li><a href="#_receiving_unicast_responses">15.1. Receiving Unicast Responses</a></li>
<li><a href="#_multipacket_known_answer_lists">15.2. Multipacket Known-Answer lists</a></li>
<li><a href="#_efficiency">15.3. Efficiency</a></li>
<li><a href="#_recommendation">15.4. Recommendation</a></li>
</ul>
</li>
<li><a href="#_multicast_dns_character_set">16. Multicast DNS Character Set</a></li>
<li><a href="#_multicast_dns_message_size">17. Multicast DNS Message Size</a></li>
<li><a href="#_multicast_dns_message_format">18. Multicast DNS Message Format</a>
<ul class="sectlevel2">
<li><a href="#_id_query_identifier">18.1. ID (Query Identifier)</a></li>
<li><a href="#_qr_queryresponse_bit">18.2. QR (Query/Response) Bit</a></li>
<li><a href="#_opcode">18.3. OPCODE</a></li>
<li><a href="#_aa_authoritative_answer_bit">18.4. AA (Authoritative Answer) Bit</a></li>
<li><a href="#_tc_truncated_bit">18.5. TC (Truncated) Bit</a></li>
<li><a href="#_rd_recursion_desired_bit">18.6. RD (Recursion Desired) Bit</a></li>
<li><a href="#_ra_recursion_available_bit">18.7. RA (Recursion Available) Bit</a></li>
<li><a href="#_z_zero_bit">18.8. Z (Zero) Bit</a></li>
<li><a href="#_ad_authentic_data_bit">18.9. AD (Authentic Data) Bit</a></li>
<li><a href="#_cd_checking_disabled_bit">18.10. CD (Checking Disabled) Bit</a></li>
<li><a href="#_rcode_response_code">18.11. RCODE (Response Code)</a></li>
<li><a href="#_repurposing_of_top_bit_of_qclass_in_question_section">18.12. Repurposing of Top Bit of qclass in Question Section</a></li>
<li><a href="#_repurposing_of_top_bit_of_rrclass_in_resource_record_sections">18.13. Repurposing of Top Bit of rrclass in Resource Record Sections</a></li>
<li><a href="#_name_compression">18.14. Name Compression</a></li>
</ul>
</li>
<li><a href="#_summary_of_differences_between_multicast_dns_and_unicast_dns">19. Summary of Differences between Multicast DNS and Unicast DNS</a></li>
<li><a href="#_ipv6_considerations">20. IPv6 Considerations</a></li>
<li><a href="#_security_considerations">21. Security Considerations</a></li>
<li><a href="#_iana_considerations">22. IANA Considerations</a>
<ul class="sectlevel2">
<li><a href="#_domain_name_reservation_considerations">22.1. Domain Name Reservation Considerations</a></li>
<li><a href="#_acknowledgments">22.2. Acknowledgments</a></li>
</ul>
</li>
<li><a href="#_references">23. References</a>
<ul class="sectlevel2">
<li><a href="#_normative_references">23.1. Normative References</a></li>
<li><a href="#_informative_references">23.2. Informative References</a></li>
</ul>
</li>
<li><a href="#appendix_A">Appendix A: Design Rationale for Choice of UDP Port Number</a></li>
<li><a href="#appendix_B">Appendix B: Design Rationale for Not Using Hashed Multicast Addresses</a></li>
<li><a href="#appendix_C">Appendix C: Design Rationale for Maximum Multicast DNS Name Length</a></li>
<li><a href="#appendix_D">Appendix D: Benefits of Multicast Responses</a></li>
<li><a href="#appendix_E">Appendix E: Design Rationale for Encoding Negative Responses</a></li>
<li><a href="#appendix_F">Appendix F: Use of UTF-8</a></li>
<li><a href="#_private_dns_namespaces">Appendix G: Private DNS Namespaces</a></li>
<li><a href="#_deployment_history">Appendix H: Deployment History</a></li>
<li><a href="#_authors_addresses">Authors' Addresses</a></li>
<li><a href="#_errata">Errata</a>
<ul class="sectlevel2">
<li><a href="#_reported">Reported</a>
<ul class="sectlevel3">
<li><a href="#_4977">4977</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<table class="tableblock frame-none grid-all stripes-none" style="width: 99%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Internet Engineering Task Force (IETF)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">S. Cheshire</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Request for Comments: 6762</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">M. Krochmal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Category: Standards Track</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">Apple Inc.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ISSN: 2070-1721</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">February 2013</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-none grid-all" style="width: 99%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Multicast DNS</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As networked devices become smaller, more portable, and more
ubiquitous, the ability to operate with less configured
infrastructure is increasingly important.  In particular, the ability
to look up DNS resource record data types (including, but not limited
to, host names) in the absence of a conventional managed DNS server
is useful.</p>
</div>
<div class="paragraph">
<p>Multicast DNS (mDNS) provides the ability to perform DNS-like
operations on the local link in the absence of any conventional
Unicast DNS server.  In addition, Multicast DNS designates a portion
of the DNS namespace to be free for local use, without the need to
pay any annual fee, and without the need to set up delegations or
otherwise configure a conventional DNS server to answer for those
names.</p>
</div>
<div class="paragraph">
<p>The primary benefits of Multicast DNS names are that (i) they require
little or no administration or configuration to set them up, (ii)
they work when no infrastructure is present, and (iii) they work
during infrastructure failures.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_status_of_this_memo">Status of This Memo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an Internet Standards Track document.</p>
</div>
<div class="paragraph">
<p>This document is a product of the Internet Engineering Task Force
(IETF).  It represents the consensus of the IETF community.  It has
received public review and has been approved for publication by the
Internet Engineering Steering Group (IESG).  Further information on
Internet Standards is available in Section 2 of RFC 5741.</p>
</div>
<div class="paragraph">
<p>Information about the current status of this document, any errata,
and how to provide feedback on it may be obtained at
<a href="http://www.rfc-editor.org/info/rfc6762" class="bare">http://www.rfc-editor.org/info/rfc6762</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright_notice">Copyright Notice</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright (c) 2013 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
</div>
<div class="paragraph">
<p>This document is subject to BCP 78 and the IETF Trust&#8217;s Legal
Provisions Relating to IETF Documents
(<a href="http://trustee.ietf.org/license-info" class="bare">http://trustee.ietf.org/license-info</a>) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document.  Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
</div>
<div class="paragraph">
<p>This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008.  The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multicast DNS and its companion technology DNS-Based Service
Discovery [<a href="#ref_RFC6763">RFC6763</a>] were created to provide IP networking with the
ease-of-use and autoconfiguration for which AppleTalk was well-known
[<a href="#ref_RFC6760">RFC6760</a>].  When reading this document, familiarity with the concepts
of Zero Configuration Networking [<a href="#ref_Zeroconf">Zeroconf</a>] and automatic link-local
addressing [<a href="#ref_RFC3927">RFC3927</a>] [<a href="#ref_RFC4862">RFC4862</a>] is helpful.</p>
</div>
<div class="paragraph">
<p>Multicast DNS borrows heavily from the existing DNS protocol
[<a href="#ref_RFC1034">RFC1034</a>] [<a href="#ref_RFC1035">RFC1035</a>] [<a href="#ref_RFC6195">RFC6195</a>], using the existing DNS message
structure, name syntax, and resource record types.  This document
specifies no new operation codes or response codes.  This document
describes how clients send DNS-like queries via IP multicast, and how
a collection of hosts cooperate to collectively answer those queries
in a useful manner.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conventions_and_terminology_used_in_this_document">2. Conventions and Terminology Used in This Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in "Key words for use in
RFCs to Indicate Requirement Levels" [<a href="#ref_RFC2119">RFC2119</a>].</p>
</div>
<div class="paragraph">
<p>When this document uses the term "Multicast DNS", it should be taken
to mean: "Clients performing DNS-like queries for DNS-like resource
records by sending DNS-like UDP query and response messages over IP
Multicast to UDP port 5353".  The design rationale for selecting UDP
port 5353 is discussed in <a href="#appendix_A">Appendix A</a>.</p>
</div>
<div class="paragraph">
<p>This document uses the term "host name" in the strict sense to mean a
fully qualified domain name that has an IPv4 or IPv6 address record.
It does not use the term "host name" in the commonly used but
incorrect sense to mean just the first DNS label of a host&#8217;s fully
qualified domain name.</p>
</div>
<div class="paragraph">
<p>A DNS (or mDNS) packet contains an IP Time to Live (TTL) in the IP
header, which is effectively a hop-count limit for the packet, to
guard against routing loops.  Each resource record also contains a
TTL, which is the number of seconds for which the resource record may
be cached.  This document uses the term "IP TTL" to refer to the IP
header TTL (hop limit), and the term "RR TTL" or just "TTL" to refer
to the resource record TTL (cache lifetime).</p>
</div>
<div class="paragraph">
<p>DNS-format messages contain a header, a Question Section, then
Answer, Authority, and Additional Record Sections.  The Answer,
Authority, and Additional Record Sections all hold resource records
in the same format.  Where this document describes issues that apply
equally to all three sections, it uses the term "Resource Record
Sections" to refer collectively to these three sections.</p>
</div>
<div class="paragraph">
<p>This document uses the terms "shared" and "unique" when referring to
resource record sets [<a href="#ref_RFC1034">RFC1034</a>]:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>A "shared" resource record set is one where several Multicast DNS
responders may have records with the same name, rrtype, and
rrclass, and several responders may respond to a particular query.</p>
</div>
<div class="paragraph">
<p>A "unique" resource record set is one where all the records with
that name, rrtype, and rrclass are conceptually under the control
or ownership of a single responder, and it is expected that at
most one responder should respond to a query for that name,
rrtype, and rrclass.  Before claiming ownership of a unique
resource record set, a responder MUST probe to verify that no
other responder already claims ownership of that set, as described
in Section <a href="#_probing">8.1</a>, "Probing".  (For fault-tolerance and other
reasons, sometimes it is permissible to have more than one
responder answering for a particular "unique" resource record set,
but such cooperating responders MUST give answers containing
identical rdata for these records.  If they do not give answers
containing identical rdata, then the probing step will reject the
data as being inconsistent with what is already being advertised
on the network for those names.)</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Strictly speaking, the terms "shared" and "unique" apply to resource
record sets, not to individual resource records.  However, it is
sometimes convenient to talk of "shared resource records" and "unique
resource records".  When used this way, the terms should be
understood to mean a record that is a member of a "shared" or
"unique" resource record set, respectively.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multicast_dns_names">3. Multicast DNS Names</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A host that belongs to an organization or individual who has control
over some portion of the DNS namespace can be assigned a globally
unique name within that portion of the DNS namespace, such as,
"cheshire.example.com.".  For those of us who have this luxury, this
works very well.  However, the majority of home computer users do not
have easy access to any portion of the global DNS namespace within
which they have the authority to create names.  This leaves the
majority of home computers effectively anonymous for practical
purposes.
To remedy this problem, this document allows any computer user to
elect to give their computers link-local Multicast DNS host names of
the form: "single-dns-label.local.".  For example, a laptop computer
may answer to the name "MyComputer.local.".  Any computer user is
granted the authority to name their computer this way, provided that
the chosen host name is not already in use on that link.  Having
named their computer this way, the user has the authority to continue
utilizing that name until such time as a name conflict occurs on the
link that is not resolved in the user&#8217;s favor.  If this happens, the
computer (or its human user) MUST cease using the name, and SHOULD
attempt to allocate a new unique name for use on that link.  These
conflicts are expected to be relatively rare for people who choose
reasonably imaginative names, but it is still important to have a
mechanism in place to handle them when they happen.</p>
</div>
<div class="paragraph">
<p>This document specifies that the DNS top-level domain ".local." is a
special domain with special semantics, namely that any fully
qualified name ending in ".local." is link-local, and names within
this domain are meaningful only on the link where they originate.
This is analogous to IPv4 addresses in the 169.254/16 prefix or IPv6
addresses in the FE80::/10 prefix, which are link-local and
meaningful only on the link where they originate.</p>
</div>
<div class="paragraph">
<p>Any DNS query for a name ending with ".local." MUST be sent to the
mDNS IPv4 link-local multicast address 224.0.0.251 (or its IPv6
equivalent FF02::FB).  The design rationale for using a fixed
multicast address instead of selecting from a range of multicast
addresses using a hash function is discussed in <a href="#appendix_B">Appendix B</a>.
Implementers MAY choose to look up such names concurrently via other
mechanisms (e.g., Unicast DNS) and coalesce the results in some
fashion.  Implementers choosing to do this should be aware of the
potential for user confusion when a given name can produce different
results depending on external network conditions (such as, but not
limited to, which name lookup mechanism responds faster).</p>
</div>
<div class="paragraph">
<p>It is unimportant whether a name ending with ".local." occurred
because the user explicitly typed in a fully qualified domain name
ending in ".local.", or because the user entered an unqualified
domain name and the host software appended the suffix ".local."
because that suffix appears in the user&#8217;s search list.  The ".local."
suffix could appear in the search list because the user manually
configured it, or because it was received via DHCP [<a href="#ref_RFC2132">RFC2132</a>] or via
any other mechanism for configuring the DNS search list.  In this
respect the ".local." suffix is treated no differently from any other
search domain that might appear in the DNS search list.
DNS queries for names that do not end with ".local." MAY be sent to
the mDNS multicast address, if no other conventional DNS server is
available.  This can allow hosts on the same link to continue
communicating using each other&#8217;s globally unique DNS names during
network outages that disrupt communication with the greater Internet.
When resolving global names via local multicast, it is even more
important to use DNS Security Extensions (DNSSEC) [<a href="#ref_RFC4033">RFC4033</a>] or other
security mechanisms to ensure that the response is trustworthy.
Resolving global names via local multicast is a contentious issue,
and this document does not discuss it further, instead concentrating
on the issue of resolving local names using DNS messages sent to a
multicast address.</p>
</div>
<div class="paragraph">
<p>This document recommends a single flat namespace for dot-local host
names, (i.e., the names of DNS "A" and "AAAA" records, which map
names to IPv4 and IPv6 addresses), but other DNS record types (such
as those used by DNS-Based Service Discovery [<a href="#ref_RFC6763">RFC6763</a>]) may contain
as many labels as appropriate for the desired usage, up to a maximum
of 255 bytes, plus a terminating zero byte at the end.  Name length
issues are discussed further in <a href="#appendix_C">Appendix C</a>.</p>
</div>
<div class="paragraph">
<p>Enforcing uniqueness of host names is probably desirable in the
common case, but this document does not mandate that.  It is
permissible for a collection of coordinated hosts to agree to
maintain multiple DNS address records with the same name, possibly
for load-balancing or fault-tolerance reasons.  This document does
not take a position on whether that is sensible.  It is important
that both modes of operation be supported.  The Multicast DNS
protocol allows hosts to verify and maintain unique names for
resource records where that behavior is desired, and it also allows
hosts to maintain multiple resource records with a single shared name
where that behavior is desired.  This consideration applies to all
resource records, not just address records (host names).  In summary:
It is required that the protocol have the ability to detect and
handle name conflicts, but it is not required that this ability be
used for every record.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reverse_address_mapping">4. Reverse Address Mapping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like ".local.", the IPv4 and IPv6 reverse mapping domains are also
defined to be link-local:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Any DNS query for a name ending with "254.169.in-addr.arpa." MUST
be sent to the mDNS IPv4 link-local multicast address 224.0.0.251
or the mDNS IPv6 multicast address FF02::FB.  Since names under
this domain correspond to IPv4 link-local addresses, it is logical
that the local link is the best place to find information
pertaining to those names.
Likewise, any DNS query for a name within the reverse mapping
domains for IPv6 link-local addresses ("8.e.f.ip6.arpa.",
"9.e.f.ip6.arpa.", "a.e.f.ip6.arpa.", and "b.e.f.ip6.arpa.") MUST
be sent to the mDNS IPv6 link-local multicast address FF02::FB or
the mDNS IPv4 link-local multicast address 224.0.0.251.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_querying">5. Querying</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two kinds of Multicast DNS queries: one-shot queries of the
kind made by legacy DNS resolvers, and continuous, ongoing Multicast
DNS queries made by fully compliant Multicast DNS queriers, which
support asynchronous operations including DNS-Based Service Discovery
[<a href="#ref_RFC6763">RFC6763</a>].</p>
</div>
<div class="paragraph">
<p>Except in the rare case of a Multicast DNS responder that is
advertising only shared resource records and no unique records, a
Multicast DNS responder MUST also implement a Multicast DNS querier
so that it can first verify the uniqueness of those records before it
begins answering queries for them.</p>
</div>
<div class="sect2">
<h3 id="_one_shot_multicast_dns_queries">5.1. One-Shot Multicast DNS Queries</h3>
<div class="paragraph">
<p>The most basic kind of Multicast DNS client may simply send standard
DNS queries blindly to 224.0.0.251:5353, without necessarily even
being aware of what a multicast address is.  This change can
typically be implemented with just a few lines of code in an existing
DNS resolver library.  If a name being queried falls within one of
the reserved Multicast DNS domains (see Sections <a href="#_multicast_dns_names">3</a> and <a href="#_reverse_address_mapping">4</a>), then,
rather than using the configured Unicast DNS server address, the
query is instead sent to 224.0.0.251:5353 (or its IPv6 equivalent
[FF02::FB]:5353).  Typically, the timeout would also be shortened to
two or three seconds.  It&#8217;s possible to make a minimal Multicast DNS
resolver with only these simple changes.  These queries are typically
done using a high-numbered ephemeral UDP source port, but regardless
of whether they are sent from a dynamic port or from a fixed port,
these queries MUST NOT be sent using UDP source port 5353, since
using UDP source port 5353 signals the presence of a fully compliant
Multicast DNS querier, as described below.</p>
</div>
<div class="paragraph">
<p>A simple DNS resolver like this will typically just take the first
response it receives.  It will not listen for additional UDP
responses, but in many instances this may not be a serious problem.
If a user types "http://MyPrinter.local." into their web browser, and
their simple DNS resolver just takes the first response it receives,
and the user gets to see the status and configuration web page for
their printer, then the protocol has met the user&#8217;s needs in this
case.
While a basic DNS resolver like this may be adequate for simple host
name lookup, it may not get ideal behavior in other cases.
Additional refinements to create a fully compliant Multicast DNS
querier are described below.</p>
</div>
</div>
<div class="sect2">
<h3 id="_continuous_multicast_dns_querying">5.2. Continuous Multicast DNS Querying</h3>
<div class="paragraph">
<p>In one-shot queries, the underlying assumption is that the
transaction begins when the application issues a query, and ends when
the first response is received.  There is another type of query
operation that is more asynchronous, in which having received one
response is not necessarily an indication that there will be no more
relevant responses, and the querying operation continues until no
further responses are required.  Determining when no further
responses are required depends on the type of operation being
performed.  If the operation is looking up the IPv4 and IPv6
addresses of another host, then no further responses are required
once a successful connection has been made to one of those IPv4 or
IPv6 addresses.  If the operation is browsing to present the user
with a list of DNS-SD services found on the network [<a href="#ref_RFC6763">RFC6763</a>], then
no further responses are required once the user indicates this to the
user-interface software, e.g., by closing the network browsing window
that was displaying the list of discovered services.</p>
</div>
<div class="paragraph">
<p>Imagine some hypothetical software that allows users to discover
network printers.  The user wishes to discover all printers on the
local network, not only the printer that is quickest to respond.
When the user is actively looking for a network printer to use, they
open a network browsing window that displays the list of discovered
printers.  It would be convenient for the user if they could rely on
this list of network printers to stay up to date as network printers
come and go, rather than displaying out-of-date stale information,
and requiring the user explicitly to click a "refresh" button any
time they want to see accurate information (which, from the moment it
is displayed, is itself already beginning to become out-of-date and
stale).  If we are to display a continuously updated live list like
this, we need to be able to do it efficiently, without naive constant
polling, which would be an unreasonable burden on the network.  It is
not expected that all users will be browsing to discover new printers
all the time, but when a user is browsing to discover service
instances for an extended period, we want to be able to support that
operation efficiently.</p>
</div>
<div class="paragraph">
<p>Therefore, when retransmitting Multicast DNS queries to implement
this kind of continuous monitoring, the interval between the first
two queries MUST be at least one second, the intervals between
successive queries MUST increase by at least a factor of two, and the
querier MUST implement Known-Answer Suppression, as described below
in Section <a href="#_known_answer_suppression">7.1</a>.  The Known-Answer Suppression mechanism tells
responders which answers are already known to the querier, thereby
allowing responders to avoid wasting network capacity with pointless
repeated transmission of those answers.  A querier retransmits its
question because it wishes to receive answers it may have missed the
first time, not because it wants additional duplicate copies of
answers it already received.  Failure to implement Known-Answer
Suppression can result in unacceptable levels of network traffic.
When the interval between queries reaches or exceeds 60 minutes, a
querier MAY cap the interval to a maximum of 60 minutes, and perform
subsequent queries at a steady-state rate of one query per hour.  To
avoid accidental synchronization when, for some reason, multiple
clients begin querying at exactly the same moment (e.g., because of
some common external trigger event), a Multicast DNS querier SHOULD
also delay the first query of the series by a randomly chosen amount
in the range 20-120 ms.</p>
</div>
<div class="paragraph">
<p>When a Multicast DNS querier receives an answer, the answer contains
a TTL value that indicates for how many seconds this answer is valid.
After this interval has passed, the answer will no longer be valid
and SHOULD be deleted from the cache.  Before the record expiry time
is reached, a Multicast DNS querier that has local clients with an
active interest in the state of that record (e.g., a network browsing
window displaying a list of discovered services to the user) SHOULD
reissue its query to determine whether the record is still valid.</p>
</div>
<div class="paragraph">
<p>To perform this cache maintenance, a Multicast DNS querier should
plan to retransmit its query after at least 50% of the record
lifetime has elapsed.  This document recommends the following
specific strategy.</p>
</div>
<div class="paragraph">
<p>The querier should plan to issue a query at 80% of the record
lifetime, and then if no answer is received, at 85%, 90%, and 95%.
If an answer is received, then the remaining TTL is reset to the
value given in the answer, and this process repeats for as long as
the Multicast DNS querier has an ongoing interest in the record.  If
no answer is received after four queries, the record is deleted when
it reaches 100% of its lifetime.  A Multicast DNS querier MUST NOT
perform this cache maintenance for records for which it has no local
clients with an active interest.  If the expiry of a particular
record from the cache would result in no net effect to any client
software running on the querier device, and no visible effect to the
human user, then there is no reason for the Multicast DNS querier to
waste network capacity checking whether the record remains valid.</p>
</div>
<div class="paragraph">
<p>To avoid the case where multiple Multicast DNS queriers on a network
all issue their queries simultaneously, a random variation of 2% of
the record TTL should be added, so that queries are scheduled to be
performed at 80-82%, 85-87%, 90-92%, and then 95-97% of the TTL.</p>
</div>
<div class="paragraph">
<p>An additional efficiency optimization SHOULD be performed when a
Multicast DNS response is received containing a unique answer (as
indicated by the cache-flush bit being set, described in Section
<a href="#_announcements_to_flush_outdated_cache_entries">10.2</a>, "Announcements to Flush Outdated Cache Entries").  In this
case, there is no need for the querier to continue issuing a stream
of queries with exponentially increasing intervals, since the receipt
of a unique answer is a good indication that no other answers will be
forthcoming.  In this case, the Multicast DNS querier SHOULD plan to
issue its next query for this record at 80-82% of the record&#8217;s TTL,
as described above.</p>
</div>
<div class="paragraph">
<p>A compliant Multicast DNS querier, which implements the rules
specified in this document, MUST send its Multicast DNS queries from
UDP source port 5353 (the well-known port assigned to mDNS), and MUST
listen for Multicast DNS replies sent to UDP destination port 5353 at
the mDNS link-local multicast address (224.0.0.251 and/or its IPv6
equivalent FF02::FB).</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_questions_per_query">5.3. Multiple Questions per Query</h3>
<div class="paragraph">
<p>Multicast DNS allows a querier to place multiple questions in the
Question Section of a single Multicast DNS query message.</p>
</div>
<div class="paragraph">
<p>The semantics of a Multicast DNS query message containing multiple
questions is identical to a series of individual DNS query messages
containing one question each.  Combining multiple questions into a
single message is purely an efficiency optimization and has no other
semantic significance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_questions_requesting_unicast_responses">5.4. Questions Requesting Unicast Responses</h3>
<div class="paragraph">
<p>Sending Multicast DNS responses via multicast has the benefit that
all the other hosts on the network get to see those responses,
enabling them to keep their caches up to date and detect conflicting
responses.</p>
</div>
<div class="paragraph">
<p>However, there are situations where all the other hosts on the
network don&#8217;t need to see every response.  Some examples are a laptop
computer waking from sleep, the Ethernet cable being connected to a
running machine, or a previously inactive interface being activated
through a configuration change.  At the instant of wake-up or link
activation, the machine is a brand new participant on a new network.
Its Multicast DNS cache for that interface is empty, and it has no
knowledge of its peers on that link.  It may have a significant
number of questions that it wants answered right away, to discover
information about its new surroundings and present that information
to the user.  As a new participant on the network, it has no idea
whether the exact same questions may have been asked and answered
just seconds ago.  In this case, triggering a large sudden flood of
multicast responses may impose an unreasonable burden on the network.</p>
</div>
<div class="paragraph">
<p>To avoid large floods of potentially unnecessary responses in these
cases, Multicast DNS defines the top bit in the class field of a DNS
question as the unicast-response bit.  When this bit is set in a
question, it indicates that the querier is willing to accept unicast
replies in response to this specific query, as well as the usual
multicast responses.  These questions requesting unicast responses
are referred to as "QU" questions, to distinguish them from the more
usual questions requesting multicast responses ("QM" questions).  A
Multicast DNS querier sending its initial batch of questions
immediately on wake from sleep or interface activation SHOULD set the
unicast-response bit in those questions.</p>
</div>
<div class="paragraph">
<p>When a question is retransmitted (as described in Section <a href="#_continuous_multicast_dns_querying">5.2</a>), the
unicast-response bit SHOULD NOT be set in subsequent retransmissions
of that question.  Subsequent retransmissions SHOULD be usual "QM"
questions.  After the first question has received its responses, the
querier should have a large Known-Answer list (Section <a href="#_known_answer_suppression">7.1</a>) so that
subsequent queries should elicit few, if any, further responses.
Reverting to multicast responses as soon as possible is important
because of the benefits that multicast responses provide (see
<a href="#appendix_D">Appendix D</a>).  In addition, the unicast-response bit SHOULD be set
only for questions that are active and ready to be sent the moment of
wake from sleep or interface activation.  New questions created by
local clients afterwards should be treated as normal "QM" questions
and SHOULD NOT have the unicast-response bit set on the first
question of the series.</p>
</div>
<div class="paragraph">
<p>When receiving a question with the unicast-response bit set, a
responder SHOULD usually respond with a unicast packet directed back
to the querier.  However, if the responder has not multicast that
record recently (within one quarter of its TTL), then the responder
SHOULD instead multicast the response so as to keep all the peer
caches up to date, and to permit passive conflict detection.  In the
case of answering a probe question (Section <a href="#_probing">8.1</a>) with the unicast-
response bit set, the responder should always generate the requested
unicast response, but it may also send a multicast announcement if
the time since the last multicast announcement of that record is more
than a quarter of its TTL.
Unicast replies are subject to all the same packet generation rules
as multicast replies, including the cache-flush bit (Section <a href="#_announcements_to_flush_outdated_cache_entries">10.2</a>)
and (except when defending a unique name against a probe from another
host) randomized delays to reduce network collisions (Section <a href="#_responding">6</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_direct_unicast_queries_to_port_5353">5.5. Direct Unicast Queries to Port 5353</h3>
<div class="paragraph">
<p>In specialized applications there may be rare situations where it
makes sense for a Multicast DNS querier to send its query via unicast
to a specific machine.  When a Multicast DNS responder receives a
query via direct unicast, it SHOULD respond as it would for "QU"
questions, as described above in Section <a href="#_questions_requesting_unicast_responses">5.4</a>.  Since it is possible
for a unicast query to be received from a machine outside the local
link, responders SHOULD check that the source address in the query
packet matches the local subnet for that link (or, in the case of
IPv6, the source address has an on-link prefix) and silently ignore
the packet if not.</p>
</div>
<div class="paragraph">
<p>There may be specialized situations, outside the scope of this
document, where it is intended and desirable to create a responder
that does answer queries originating outside the local link.  Such a
responder would need to ensure that these non-local queries are
always answered via unicast back to the querier, since an answer sent
via link-local multicast would not reach a querier outside the local
link.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_responding">6. Responding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When a Multicast DNS responder constructs and sends a Multicast DNS
response message, the Resource Record Sections of that message must
contain only records for which that responder is explicitly
authoritative.  These answers may be generated because the record
answers a question received in a Multicast DNS query message, or at
certain other times that the responder determines than an unsolicited
announcement is warranted.  A Multicast DNS responder MUST NOT place
records from its cache, which have been learned from other responders
on the network, in the Resource Record Sections of outgoing response
messages.  Only an authoritative source for a given record is allowed
to issue responses containing that record.</p>
</div>
<div class="paragraph">
<p>The determination of whether a given record answers a given question
is made using the standard DNS rules: the record name must match the
question name, the record rrtype must match the question qtype unless
the qtype is "ANY" (255) or the rrtype is "CNAME" (5), and the record
rrclass must match the question qclass unless the qclass is "ANY"
(255).  As with Unicast DNS, generally only DNS class 1 ("Internet")
is used, but should client software use classes other than 1, the
matching rules described above MUST be used.</p>
</div>
<div class="paragraph">
<p>A Multicast DNS responder MUST only respond when it has a positive,
non-null response to send, or it authoritatively knows that a
particular record does not exist.  For unique records, where the host
has already established sole ownership of the name, it MUST return
negative answers to queries for records that it knows not to exist.
For example, a host with no IPv6 address, that has claimed sole
ownership of the name "host.local." for all rrtypes, MUST respond to
AAAA queries for "host.local." by sending a negative answer
indicating that no AAAA records exist for that name.  See Section
<a href="#_negative_responses">6.1</a>, "Negative Responses".  For shared records, which are owned by no
single host, the nonexistence of a given record is ascertained by the
failure of any machine to respond to the Multicast DNS query, not by
any explicit negative response.  For shared records, NXDOMAIN and
other error responses MUST NOT be sent.</p>
</div>
<div class="paragraph">
<p>Multicast DNS responses MUST NOT contain any questions in the
Question Section.  Any questions in the Question Section of a
received Multicast DNS response MUST be silently ignored.  Multicast
DNS queriers receiving Multicast DNS responses do not care what
question elicited the response; they care only that the information
in the response is true and accurate.</p>
</div>
<div class="paragraph">
<p>A Multicast DNS responder on Ethernet [<a href="#ref_IEEE.802.3">IEEE.802.3</a>] and similar shared
multiple access networks SHOULD have the capability of delaying its
responses by up to 500 ms, as described below.</p>
</div>
<div class="paragraph">
<p>If a large number of Multicast DNS responders were all to respond
immediately to a particular query, a collision would be virtually
guaranteed.  By imposing a small random delay, the number of
collisions is dramatically reduced.  On a full-sized Ethernet using
the maximum cable lengths allowed and the maximum number of repeaters
allowed, an Ethernet frame is vulnerable to collisions during the
transmission of its first 256 bits.  On 10 Mb/s Ethernet, this
equates to a vulnerable time window of 25.6 microseconds.  On higher-
speed variants of Ethernet, the vulnerable time window is shorter.</p>
</div>
<div class="paragraph">
<p>In the case where a Multicast DNS responder has good reason to
believe that it will be the only responder on the link that will send
a response (i.e., because it is able to answer every question in the
query message, and for all of those answer records it has previously
verified that the name, rrtype, and rrclass are unique on the link),
it SHOULD NOT impose any random delay before responding, and SHOULD
normally generate its response within at most 10 ms.  In particular,
this applies to responding to probe queries with the unicast-response
bit set.  Since receiving a probe query gives a clear indication that
some other responder is planning to start using this name in the very
near future, answering such probe queries to defend a unique record
is a high priority and needs to be done without delay.  A probe query
can be distinguished from a normal query by the fact that a probe
query contains a proposed record in the Authority Section that
answers the question in the Question Section (for more details, see
Section <a href="#_simultaneous_probe_tiebreaking">8.2</a>, "Simultaneous Probe Tiebreaking").</p>
</div>
<div class="paragraph">
<p>Responding without delay is appropriate for records like the address
record for a particular host name, when the host name has been
previously verified unique.  Responding without delay is <strong>not</strong>
appropriate for things like looking up PTR records used for DNS-Based
Service Discovery [<a href="#ref_RFC6763">RFC6763</a>], where a large number of responses may be
anticipated.</p>
</div>
<div class="paragraph">
<p>In any case where there may be multiple responses, such as queries
where the answer is a member of a shared resource record set, each
responder SHOULD delay its response by a random amount of time
selected with uniform random distribution in the range 20-120 ms.
The reason for requiring that the delay be at least 20 ms is to
accommodate the situation where two or more query packets are sent
back-to-back, because in that case we want a responder with answers
to more than one of those queries to have the opportunity to
aggregate all of its answers into a single response message.</p>
</div>
<div class="paragraph">
<p>In the case where the query has the TC (truncated) bit set,
indicating that subsequent Known-Answer packets will follow,
responders SHOULD delay their responses by a random amount of time
selected with uniform random distribution in the range 400-500 ms, to
allow enough time for all the Known-Answer packets to arrive, as
described in Section <a href="#_multipacket_known_answer_suppression">7.2</a>, "Multipacket Known-Answer Suppression".</p>
</div>
<div class="paragraph">
<p>The source UDP port in all Multicast DNS responses MUST be 5353 (the
well-known port assigned to mDNS).  Multicast DNS implementations
MUST silently ignore any Multicast DNS responses they receive where
the source UDP port is not 5353.</p>
</div>
<div class="paragraph">
<p>The destination UDP port in all Multicast DNS responses MUST be 5353,
and the destination address MUST be the mDNS IPv4 link-local
multicast address 224.0.0.251 or its IPv6 equivalent FF02::FB, except
when generating a reply to a query that explicitly requested a
unicast response:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>via the unicast-response bit,</p>
</li>
<li>
<p>by virtue of being a legacy query (Section <a href="#_legacy_unicast_responses">6.7</a>), or</p>
</li>
<li>
<p>by virtue of being a direct unicast query.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Except for these three specific cases, responses MUST NOT be sent via
unicast, because then the "Passive Observation of Failures"
mechanisms described in Section <a href="#_passive_observation_of_failures_poof">10.5</a> would not work correctly.  Other
benefits of sending responses via multicast are discussed in
<a href="#appendix_D">Appendix D</a>.  A Multicast DNS querier MUST only accept unicast responses if
they answer a recently sent query (e.g., sent within the last two
seconds) that explicitly requested unicast responses.  A Multicast
DNS querier MUST silently ignore all other unicast responses.</p>
</div>
<div class="paragraph">
<p>To protect the network against excessive packet flooding due to
software bugs or malicious attack, a Multicast DNS responder MUST NOT
(except in the one special case of answering probe queries) multicast
a record on a given interface until at least one second has elapsed
since the last time that record was multicast on that particular
interface.  A legitimate querier on the network should have seen the
previous transmission and cached it.  A querier that did not receive
and cache the previous transmission will retry its request and
receive a subsequent response.  In the special case of answering
probe queries, because of the limited time before the probing host
will make its decision about whether or not to use the name, a
Multicast DNS responder MUST respond quickly.  In this special case
only, when responding via multicast to a probe, a Multicast DNS
responder is only required to delay its transmission as necessary to
ensure an interval of at least 250 ms since the last time the record
was multicast on that interface.</p>
</div>
<div class="sect2">
<h3 id="_negative_responses">6.1. Negative Responses</h3>
<div class="paragraph">
<p>In the early design of Multicast DNS it was assumed that explicit
negative responses would never be needed.  A host can assert the
existence of the set of records that it claims to exist, and the
union of all such sets on a link is the set of Multicast DNS records
that exist on that link.  Asserting the nonexistence of every record
in the complement of that set&#8201;&#8212;&#8201;i.e., all possible Multicast DNS
records that could exist on this link but do not at this moment&#8201;&#8212;&#8201;was felt to be impractical and unnecessary.  The nonexistence of a
record would be ascertained by a querier querying for it and failing
to receive a response from any of the hosts currently attached to the
link.</p>
</div>
<div class="paragraph">
<p>However, operational experience showed that explicit negative
responses can sometimes be valuable.  One such example is when a
querier is querying for a AAAA record, and the host name in question
has no associated IPv6 addresses.  In this case, the responding host
knows it currently has exclusive ownership of that name, and it knows
that it currently does not have any IPv6 addresses, so an explicit
negative response is preferable to the querier having to retransmit
its query multiple times, and eventually give up with a timeout,
before it can conclude that a given AAAA record does not exist.</p>
</div>
<div class="paragraph">
<p>Any time a responder receives a query for a name for which it has
verified exclusive ownership, for a type for which that name has no
records, the responder MUST (except as allowed in (a) below) respond
asserting the nonexistence of that record using a DNS NSEC record
[<a href="#ref_RFC4034">RFC4034</a>].  In the case of Multicast DNS the NSEC record is not being
used for its usual DNSSEC [<a href="#ref_RFC4033">RFC4033</a>] security properties, but simply
as a way of expressing which records do or do not exist with a given
name.</p>
</div>
<div class="paragraph">
<p>On receipt of a question for a particular name, rrtype, and rrclass,
for which a responder does have one or more unique answers, the
responder MAY also include an NSEC record in the Additional Record
Section indicating the nonexistence of other rrtypes for that name
and rrclass.</p>
</div>
<div class="paragraph">
<p>Implementers working with devices with sufficient memory and CPU
resources MAY choose to implement code to handle the full generality
of the DNS NSEC record [<a href="#ref_RFC4034">RFC4034</a>], including bitmaps up to 65,536 bits
long.  To facilitate use by devices with limited memory and CPU
resources, Multicast DNS queriers are only REQUIRED to be able to
parse a restricted form of the DNS NSEC record.  All compliant
Multicast DNS implementations MUST at least correctly generate and
parse the restricted DNS NSEC record format described below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="rfc-error-text">The 'Next Domain Name' field contains the record&#8217;s own name.
When used with name compression, this means that the 'Next
Domain Name' field always takes exactly two bytes in the
message.</span></p>
</li>
<li>
<p>The Type Bit Map block number is 0.</p>
</li>
<li>
<p>The Type Bit Map block length byte is a value in the range 1-32.</p>
</li>
<li>
<p>The Type Bit Map data is 1-32 bytes, as indicated by length
byte.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because this restricted form of the DNS NSEC record is limited to
Type Bit Map block number zero, it cannot express the existence of
rrtypes above 255.  Consequently, if a Multicast DNS responder were
to have records with rrtypes above 255, it MUST NOT generate these
restricted-form NSEC records for those names, since to do so would
imply that the name has no records with rrtypes above 255, which
would be false.  In such cases a Multicast DNS responder MUST either
(a) emit no NSEC record for that name, or (b) emit a full NSEC record
containing the appropriate Type Bit Map block(s) with the correct
bits set for all the record types that exist.  In practice this is
not a significant limitation, since rrtypes above 255 are not
currently in widespread use.
If a Multicast DNS implementation receives an NSEC record where the
'Next Domain Name' field is not the record&#8217;s own name, then the
implementation SHOULD ignore the 'Next Domain Name' field and process
the remainder of the NSEC record as usual.  In Multicast DNS the
'Next Domain Name' field is not currently used, but it could be used
in a future version of this protocol, which is why a Multicast DNS
implementation MUST NOT reject or ignore an NSEC record it receives
just because it finds an unexpected value in the 'Next Domain Name'
field.</p>
</div>
<div class="paragraph">
<p>If a Multicast DNS implementation receives an NSEC record containing
more than one Type Bit Map, or where the Type Bit Map block number is
not zero, or where the block length is not in the range 1-32, then
the Multicast DNS implementation MAY silently ignore the entire NSEC
record.  A Multicast DNS implementation MUST NOT ignore an entire
message just because that message contains one or more NSEC record(s)
that the Multicast DNS implementation cannot parse.  This provision
is to allow future enhancements to the protocol to be introduced in a
backwards-compatible way that does not break compatibility with older
Multicast DNS implementations.</p>
</div>
<div class="paragraph">
<p>To help differentiate these synthesized NSEC records (generated
programmatically on-the-fly) from conventional Unicast DNS NSEC
records (which actually exist in a signed DNS zone), the synthesized
Multicast DNS NSEC records MUST NOT have the NSEC bit set in the Type
Bit Map, whereas conventional Unicast DNS NSEC records do have the
NSEC bit set.</p>
</div>
<div class="paragraph">
<p>The TTL of the NSEC record indicates the intended lifetime of the
negative cache entry.  In general, the TTL given for an NSEC record
SHOULD be the same as the TTL that the record would have had, had it
existed.  For example, the TTL for address records in Multicast DNS
is typically 120 seconds (see Section <a href="#_resource_record_ttl_values_and_cache_coherency">10</a>), so the negative cache
lifetime for an address record that does not exist should also be 120
seconds.</p>
</div>
<div class="paragraph">
<p>A responder MUST only generate negative responses to queries for
which it has legitimate ownership of the name, rrtype, and rrclass in
question, and can legitimately assert that no record with that name,
rrtype, and rrclass exists.  A responder can assert that a specified
rrtype does not exist for one of its names if it knows a priori that
it has exclusive ownership of that name (e.g., names of reverse
address mapping PTR records, which are derived from IP addresses,
which should be unique on the local link) or if it previously claimed
unique ownership of that name using probe queries for rrtype "ANY".
(If it were to use probe queries for a specific rrtype, then it would
only own the name for that rrtype, and could not assert that other
rrtypes do not exist.)
The design rationale for this mechanism for encoding negative
responses is discussed further in <a href="#appendix_E">Appendix E</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_responding_to_address_queries">6.2. Responding to Address Queries</h3>
<div class="paragraph">
<p>When a Multicast DNS responder sends a Multicast DNS response message
containing its own address records, it MUST include all addresses
that are valid on the interface on which it is sending the message,
and MUST NOT include addresses that are not valid on that interface
(such as addresses that may be configured on the host&#8217;s other
interfaces).  For example, if an interface has both an IPv6 link-
local and an IPv6 routable address, both should be included in the
response message so that queriers receive both and can make their own
choice about which to use.  This allows a querier that only has an
IPv6 link-local address to connect to the link-local address, and a
different querier that has an IPv6 routable address to connect to the
IPv6 routable address instead.</p>
</div>
<div class="paragraph">
<p>When a Multicast DNS responder places an IPv4 or IPv6 address record
(rrtype "A" or "AAAA") into a response message, it SHOULD also place
any records of the other address type with the same name into the
additional section, if there is space in the message.  This is to
provide fate sharing, so that all a device&#8217;s addresses are delivered
atomically in a single message, to reduce the risk that packet loss
could cause a querier to receive only the IPv4 addresses and not the
IPv6 addresses, or vice versa.</p>
</div>
<div class="paragraph">
<p>In the event that a device has only IPv4 addresses but no IPv6
addresses, or vice versa, then the appropriate NSEC record SHOULD be
placed into the additional section, so that queriers can know with
certainty that the device has no addresses of that kind.</p>
</div>
<div class="paragraph">
<p>Some Multicast DNS responders treat a physical interface with both
IPv4 and IPv6 address as a single interface with two addresses.
Other Multicast DNS responders may treat this case as logically two
interfaces (one with one or more IPv4 addresses, and the other with
one or more IPv6 addresses), but responders that operate this way
MUST NOT put the corresponding automatic NSEC records in replies they
send (i.e., a negative IPv4 assertion in their IPv6 responses, and a
negative IPv6 assertion in their IPv4 responses) because this would
cause incorrect operation in responders on the network that work the
former way.</p>
</div>
</div>
<div class="sect2">
<h3 id="_responding_to_multiquestion_queries">6.3. Responding to Multiquestion Queries</h3>
<div class="paragraph">
<p>Multicast DNS responders MUST correctly handle DNS query messages
containing more than one question, by answering any or all of the
questions to which they have answers.  Unlike single-question
queries, where responding without delay is allowed in appropriate
cases, for query messages containing more than one question, all
(non-defensive) answers SHOULD be randomly delayed in the range
20-120 ms, or 400-500 ms if the TC (truncated) bit is set.  This is
because when a query message contains more than one question, a
Multicast DNS responder cannot generally be certain that other
responders will not also be simultaneously generating answers to
other questions in that query message.  (Answers defending a name, in
response to a probe for that name, are not subject to this delay rule
and are still sent immediately.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_response_aggregation">6.4. Response Aggregation</h3>
<div class="paragraph">
<p>When possible, a responder SHOULD, for the sake of network
efficiency, aggregate as many responses as possible into a single
Multicast DNS response message.  For example, when a responder has
several responses it plans to send, each delayed by a different
interval, then earlier responses SHOULD be delayed by up to an
additional 500 ms if that will permit them to be aggregated with
other responses scheduled to go out a little later.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wildcard_queries_qtype_any_and_qclass_any">6.5. Wildcard Queries (qtype "ANY" and qclass "ANY")</h3>
<div class="paragraph">
<p>When responding to queries using qtype "ANY" (255) and/or qclass
"ANY" (255), a Multicast DNS responder MUST respond with <strong>ALL</strong> of its
records that match the query.  This is subtly different from how
qtype "ANY" and qclass "ANY" work in Unicast DNS.</p>
</div>
<div class="paragraph">
<p>A common misconception is that a Unicast DNS query for qtype "ANY"
will elicit a response containing all matching records.  This is
incorrect.  If there are any records that match the query, the
response is required only to contain at least one of them, not
necessarily all of them.</p>
</div>
<div class="paragraph">
<p>This somewhat surprising behavior is commonly seen with caching
(i.e., "recursive") name servers.  If a caching server receives a
qtype "ANY" query for which it has at least one valid answer, it is
allowed to return only those matching answers it happens to have
already in its cache, and it is not required to reconsult the
authoritative name server to check if there are any more records that
also match the qtype "ANY" query.</p>
</div>
<div class="paragraph">
<p>For example, one might imagine that a query for qtype "ANY" for name
"host.example.com" would return both the IPv4 (A) and the IPv6 (AAAA)
address records for that host.  In reality, what happens is that it
depends on the history of what queries have been previously received
by intervening caching servers.  If a caching server has no records
for "host.example.com", then it will consult another server (usually
the authoritative name server for the name in question), and, in that
case, it will typically return all IPv4 and IPv6 address records.
However, if some other host has recently done a query for qtype "A"
for name "host.example.com", so that the caching server already has
IPv4 address records for "host.example.com" in its cache but no IPv6
address records, then it will return only the IPv4 address records it
already has cached, and no IPv6 address records.</p>
</div>
<div class="paragraph">
<p>Multicast DNS does not share this property that qtype "ANY" and
qclass "ANY" queries return some undefined subset of the matching
records.  When responding to queries using qtype "ANY" (255) and/or
qclass "ANY" (255), a Multicast DNS responder MUST respond with <strong>ALL</strong>
of its records that match the query.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cooperating_multicast_dns_responders">6.6. Cooperating Multicast DNS Responders</h3>
<div class="paragraph">
<p>If a Multicast DNS responder ("A") observes some other Multicast DNS
responder ("B") send a Multicast DNS response message containing a
resource record with the same name, rrtype, and rrclass as one of A&#8217;s
resource records, but <strong>different</strong> rdata, then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If A&#8217;s resource record is intended to be a shared resource
record, then this is no conflict, and no action is required.</p>
</li>
<li>
<p>If A&#8217;s resource record is intended to be a member of a unique
resource record set owned solely by that responder, then this is
a conflict and MUST be handled as described in Section <a href="#_conflict_resolution">9</a>,
"Conflict Resolution".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a Multicast DNS responder ("A") observes some other Multicast DNS
responder ("B") send a Multicast DNS response message containing a
resource record with the same name, rrtype, and rrclass as one of A&#8217;s
resource records, and <strong>identical</strong> rdata, then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the TTL of B&#8217;s resource record given in the message is at
least half the true TTL from A&#8217;s point of view, then no action
is required.</p>
</li>
<li>
<p>If the TTL of B&#8217;s resource record given in the message is less
than half the true TTL from A&#8217;s point of view, then A MUST mark
its record to be announced via multicast.  Queriers receiving
the record from B would use the TTL given by B and, hence, may
delete the record sooner than A expects.  By sending its own
multicast response correcting the TTL, A ensures that the record
will be retained for the desired time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These rules allow multiple Multicast DNS responders to offer the same
data on the network (perhaps for fault-tolerance reasons) without
conflicting with each other.</p>
</div>
</div>
<div class="sect2">
<h3 id="_legacy_unicast_responses">6.7. Legacy Unicast Responses</h3>
<div class="paragraph">
<p>If the source UDP port in a received Multicast DNS query is not port
5353, this indicates that the querier originating the query is a
simple resolver such as described in Section <a href="#_one_shot_multicast_dns_queries">5.1</a>, "One-Shot Multicast
DNS Queries", which does not fully implement all of Multicast DNS.
In this case, the Multicast DNS responder MUST send a UDP response
directly back to the querier, via unicast, to the query packet&#8217;s
source IP address and port.  This unicast response MUST be a
conventional unicast response as would be generated by a conventional
Unicast DNS server; for example, it MUST repeat the query ID and the
question given in the query message.  In addition, the cache-flush
bit described in Section <a href="#_announcements_to_flush_outdated_cache_entries">10.2</a>, "Announcements to Flush Outdated Cache
Entries", MUST NOT be set in legacy unicast responses.</p>
</div>
<div class="paragraph">
<p>The resource record TTL given in a legacy unicast response SHOULD NOT
be greater than ten seconds, even if the true TTL of the Multicast
DNS resource record is higher.  This is because Multicast DNS
responders that fully participate in the protocol use the cache
coherency mechanisms described in Section <a href="#_resource_record_ttl_values_and_cache_coherency">10</a>, "Resource Record TTL
Values and Cache Coherency", to update and invalidate stale data.
Were unicast responses sent to legacy resolvers to use the same high
TTLs, these legacy resolvers, which do not implement these cache
coherency mechanisms, could retain stale cached resource record data
long after it is no longer valid.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traffic_reduction">7. Traffic Reduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A variety of techniques are used to reduce the amount of traffic on
the network.</p>
</div>
<div class="sect2">
<h3 id="_known_answer_suppression">7.1. Known-Answer Suppression</h3>
<div class="paragraph">
<p>When a Multicast DNS querier sends a query to which it already knows
some answers, it populates the Answer Section of the DNS query
message with those answers.</p>
</div>
<div class="paragraph">
<p>Generally, this applies only to Shared records, not Unique records,
since if a Multicast DNS querier already has at least one Unique
record in its cache then it should not be expecting further different
answers to this question, since the Unique record(s) it already has
comprise the complete answer, so it has no reason to be sending the
query at all.  In contrast, having some Shared records in its cache
does not necessarily imply that a Multicast DNS querier will not
receive further answers to this query, and it is in this case that it
is beneficial to use the Known-Answer list to suppress repeated
sending of redundant answers that the querier already knows.</p>
</div>
<div class="paragraph">
<p>A Multicast DNS responder MUST NOT answer a Multicast DNS query if
the answer it would give is already included in the Answer Section
with an RR TTL at least half the correct value.  If the RR TTL of the
answer as given in the Answer Section is less than half of the true
RR TTL as known by the Multicast DNS responder, the responder MUST
send an answer so as to update the querier&#8217;s cache before the record
becomes in danger of expiration.</p>
</div>
<div class="paragraph">
<p>Because a Multicast DNS responder will respond if the remaining TTL
given in the Known-Answer list is less than half the true TTL, it is
superfluous for the querier to include such records in the Known-
Answer list.  Therefore, a Multicast DNS querier SHOULD NOT include
records in the Known-Answer list whose remaining TTL is less than
half of their original TTL.  Doing so would simply consume space in
the message without achieving the goal of suppressing responses and
would, therefore, be a pointless waste of network capacity.</p>
</div>
<div class="paragraph">
<p>A Multicast DNS querier MUST NOT cache resource records observed in
the Known-Answer Section of other Multicast DNS queries.  The Answer
Section of Multicast DNS queries is not authoritative.  By placing
information in the Answer Section of a Multicast DNS query, the
querier is stating that it <strong>believes</strong> the information to be true.  It
is not asserting that the information <strong>is</strong> true.  Some of those
records may have come from other hosts that are no longer on the
network.  Propagating that stale information to other Multicast DNS
queriers on the network would not be helpful.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multipacket_known_answer_suppression">7.2. Multipacket Known-Answer Suppression</h3>
<div class="paragraph">
<p>Sometimes a Multicast DNS querier will already have too many answers
to fit in the Known-Answer Section of its query packets.  In this
case, it should issue a Multicast DNS query containing a question and
as many Known-Answer records as will fit.  It MUST then set the TC
(Truncated) bit in the header before sending the query.  It MUST
immediately follow the packet with another query packet containing no
questions and as many more Known-Answer records as will fit.  If
there are still too many records remaining to fit in the packet, it
again sets the TC bit and continues until all the Known-Answer
records have been sent.</p>
</div>
<div class="paragraph">
<p>A Multicast DNS responder seeing a Multicast DNS query with the TC
bit set defers its response for a time period randomly selected in
the interval 400-500 ms.  This gives the Multicast DNS querier time
to send additional Known-Answer packets before the responder
responds.  If the responder sees any of its answers listed in the
Known-Answer lists of subsequent packets from the querying host, it
MUST delete that answer from the list of answers it is planning to
give (provided that no other host on the network has also issued a
query for that record and is waiting to receive an answer).</p>
</div>
<div class="paragraph">
<p>If the responder receives additional Known-Answer packets with the TC
bit set, it SHOULD extend the delay as necessary to ensure a pause of
400-500 ms after the last such packet before it sends its answer.
This opens the potential risk that a continuous stream of Known-
Answer packets could, theoretically, prevent a responder from
answering indefinitely.  In practice, answers are never actually
delayed significantly, and should a situation arise where significant
delays did happen, that would be a scenario where the network is so
overloaded that it would be desirable to err on the side of caution.
The consequence of delaying an answer may be that it takes a user
longer than usual to discover all the services on the local network;
in contrast, the consequence of incorrectly answering before all the
Known-Answer packets have been received would be wasted capacity
sending unnecessary answers on an already overloaded network.  In
this (rare) situation, sacrificing speed to preserve reliable network
operation is the right trade-off.</p>
</div>
</div>
<div class="sect2">
<h3 id="_duplicate_question_suppression">7.3. Duplicate Question Suppression</h3>
<div class="paragraph">
<p>If a host is planning to transmit (or retransmit) a query, and it
sees another host on the network send a query containing the same
"QM" question, and the Known-Answer Section of that query does not
contain any records that this host would not also put in its own
Known-Answer Section, then this host SHOULD treat its own query as
having been sent.  When multiple queriers on the network are querying
for the same resource records, there is no need for them to all be
repeatedly asking the same question.</p>
</div>
</div>
<div class="sect2">
<h3 id="_duplicate_answer_suppression">7.4. Duplicate Answer Suppression</h3>
<div class="paragraph">
<p>If a host is planning to send an answer, and it sees another host on
the network send a response message containing the same answer
record, and the TTL in that record is not less than the TTL this host
would have given, then this host SHOULD treat its own answer as
having been sent, and not also send an identical answer itself.  When
multiple responders on the network have the same data, there is no
need for all of them to respond.</p>
</div>
<div class="paragraph">
<p>The opportunity for duplicate answer suppression occurs when a host
has received a query, and is delaying its response for some pseudo-
random interval up to 500 ms, as described elsewhere in this
document, and then, before the host sends its response, it sees some
other host on the network send a response message containing the same
answer record.</p>
</div>
<div class="paragraph">
<p>This feature is particularly useful when Multicast DNS Proxy Servers
are in use, where there could be more than one proxy on the network
giving Multicast DNS answers on behalf of some other host (e.g.,
because that other host is currently asleep and is not itself
responding to queries).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_probing_and_announcing_on_startup">8. Probing and Announcing on Startup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Typically a Multicast DNS responder should have, at the very least,
address records for all of its active interfaces.  Creating and
advertising an HINFO record on each interface as well can be useful
to network administrators.</p>
</div>
<div class="paragraph">
<p>Whenever a Multicast DNS responder starts up, wakes up from sleep,
receives an indication of a network interface "Link Change" event, or
has any other reason to believe that its network connectivity may
have changed in some relevant way, it MUST perform the two startup
steps below: Probing (Section <a href="#_probing">8.1</a>) and Announcing (Section <a href="#_announcing">8.3</a>).</p>
</div>
<div class="sect2">
<h3 id="_probing">8.1. Probing</h3>
<div class="paragraph">
<p>The first startup step is that, for all those resource records that a
Multicast DNS responder desires to be unique on the local link, it
MUST send a Multicast DNS query asking for those resource records, to
see if any of them are already in use.  The primary example of this
is a host&#8217;s address records, which map its unique host name to its
unique IPv4 and/or IPv6 addresses.  All probe queries SHOULD be done
using the desired resource record name and class (usually class 1,
"Internet"), and query type "ANY" (255), to elicit answers for all
types of records with that name.  This allows a single question to be
used in place of several questions, which is more efficient on the
network.  It also allows a host to verify exclusive ownership of a
name for all rrtypes, which is desirable in most cases.  It would be
confusing, for example, if one host owned the "A" record for
"myhost.local.", but a different host owned the "AAAA" record for
that name.</p>
</div>
<div class="paragraph">
<p>The ability to place more than one question in a Multicast DNS query
is useful here, because it can allow a host to use a single message
to probe for all of its resource records instead of needing a
separate message for each.  For example, a host can simultaneously
probe for uniqueness of its "A" record and all its SRV records
[<a href="#ref_RFC6763">RFC6763</a>] in the same query message.</p>
</div>
<div class="paragraph">
<p>When ready to send its Multicast DNS probe packet(s) the host should
first wait for a short random delay time, uniformly distributed in
the range 0-250 ms.  This random delay is to guard against the case
where several devices are powered on simultaneously, or several
devices are connected to an Ethernet hub, which is then powered on,
or some other external event happens that might cause a group of
hosts to all send synchronized probes.</p>
</div>
<div class="paragraph">
<p>250 ms after the first query, the host should send a second; then,
250 ms after that, a third.  If, by 250 ms after the third probe, no
conflicting Multicast DNS responses have been received, the host may
move to the next step, announcing.  (Note that probing is the one
exception from the normal rule that there should be at least one
second between repetitions of the same question, and the interval
between subsequent repetitions should at least double.)</p>
</div>
<div class="paragraph">
<p>When sending probe queries, a host MUST NOT consult its cache for
potential answers.  Only conflicting Multicast DNS responses received
"live" from the network are considered valid for the purposes of
determining whether probing has succeeded or failed.</p>
</div>
<div class="paragraph">
<p>In order to allow services to announce their presence without
unreasonable delay, the time window for probing is intentionally set
quite short.  As a result of this, from the time the first probe
packet is sent, another device on the network using that name has
just 750 ms to respond to defend its name.  On networks that are
slow, or busy, or both, it is possible for round-trip latency to
account for a few hundred milliseconds, and software delays in slow
devices can add additional delay.  Hence, it is important that when a
device receives a probe query for a name that it is currently using,
it SHOULD generate its response to defend that name immediately and
send it as quickly as possible.  The usual rules about random delays
before responding, to avoid sudden bursts of simultaneous answers
from different hosts, do not apply here since normally at most one
host should ever respond to a given probe question.  Even when a
single DNS query message contains multiple probe questions, it would
be unusual for that message to elicit a defensive response from more
than one other host.  Because of the mDNS multicast rate-limiting
rules, the probes SHOULD be sent as "QU" questions with the unicast-
response bit set, to allow a defending host to respond immediately
via unicast, instead of potentially having to wait before replying
via multicast.</p>
</div>
<div class="paragraph">
<p>During probing, from the time the first probe packet is sent until
250 ms after the third probe, if any conflicting Multicast DNS
response is received, then the probing host MUST defer to the
existing host, and SHOULD choose new names for some or all of its
resource records as appropriate.  Apparently conflicting Multicast
DNS responses received <strong>before</strong> the first probe packet is sent MUST
be silently ignored (see discussion of stale probe packets in Section
<a href="#_simultaneous_probe_tiebreaking">8.2</a>, "Simultaneous Probe Tiebreaking", below).  In the case of a host
probing using query type "ANY" as recommended above, any answer
containing a record with that name, of any type, MUST be considered a
conflicting response and handled accordingly.</p>
</div>
<div class="paragraph">
<p>If fifteen conflicts occur within any ten-second period, then the
host MUST wait at least five seconds before each successive
additional probe attempt.  This is to help ensure that, in the event
of software bugs or other unanticipated problems, errant hosts do not
flood the network with a continuous stream of multicast traffic.  For
very simple devices, a valid way to comply with this requirement is
to always wait five seconds after any failed probe attempt before
trying again.</p>
</div>
<div class="paragraph">
<p>If a responder knows by other means that its unique resource record
set name, rrtype, and rrclass cannot already be in use by any other
responder on the network, then it SHOULD skip the probing step for
that resource record set.  For example, when creating the reverse
address mapping PTR records, the host can reasonably assume that no
other host will be trying to create those same PTR records, since
that would imply that the two hosts were trying to use the same IP
address, and if that were the case, the two hosts would be suffering
communication problems beyond the scope of what Multicast DNS is
designed to solve.  Similarly, if a responder is acting as a proxy,
taking over from another Multicast DNS responder that has already
verified the uniqueness of the record, then the proxy SHOULD NOT
repeat the probing step for those records.</p>
</div>
</div>
<div class="sect2">
<h3 id="_simultaneous_probe_tiebreaking">8.2. Simultaneous Probe Tiebreaking</h3>
<div class="paragraph">
<p>The astute reader will observe that there is a race condition
inherent in the previous description.  If two hosts are probing for
the same name simultaneously, neither will receive any response to
the probe, and the hosts could incorrectly conclude that they may
both proceed to use the name.  To break this symmetry, each host
populates the query message&#8217;s Authority Section with the record or
records with the rdata that it would be proposing to use, should its
probing be successful.  The Authority Section is being used here in a
way analogous to the way it is used as the "Update Section" in a DNS
Update message [<a href="#ref_RFC2136">RFC2136</a>] [<a href="#ref_RFC3007">RFC3007</a>].</p>
</div>
<div class="paragraph">
<p>When a host is probing for a group of related records with the same
name (e.g., the SRV and TXT record describing a DNS-SD service), only
a single question need be placed in the Question Section, since query
type "ANY" (255) is used, which will elicit answers for all records
with that name.  However, for tiebreaking to work correctly in all
cases, the Authority Section must contain <strong>all</strong> the records and
proposed rdata being probed for uniqueness.</p>
</div>
<div class="paragraph">
<p>When a host that is probing for a record sees another host issue a
query for the same record, it consults the Authority Section of that
query.  If it finds any resource record(s) there which answers the
query, then it compares the data of that (those) resource record(s)
with its own tentative data.  We consider first the simple case of a
host probing for a single record, receiving a simultaneous probe from
another host also probing for a single record.  The two records are
compared and the lexicographically later data wins.  This means that
if the host finds that its own data is lexicographically later, it
simply ignores the other host&#8217;s probe.  If the host finds that its
own data is lexicographically earlier, then it defers to the winning
host by waiting one second, and then begins probing for this record
again.  The logic for waiting one second and then trying again is to
guard against stale probe packets on the network (possibly even stale
probe packets sent moments ago by this host itself, before some
configuration change, which may be echoed back after a short delay by
some Ethernet switches and some 802.11 base stations).  If the
winning simultaneous probe was from a real other host on the network,
then after one second it will have completed its probing, and will
answer subsequent probes.  If the apparently winning simultaneous
probe was in fact just an old stale packet on the network (maybe from
the host itself), then when it retries its probing in one second, its
probes will go unanswered, and it will successfully claim the name.</p>
</div>
<div class="paragraph">
<p>The determination of "lexicographically later" is performed by first
comparing the record class (excluding the cache-flush bit described
in Section <a href="#_announcements_to_flush_outdated_cache_entries">10.2</a>), then the record type, then raw comparison of the
binary content of the rdata without regard for meaning or structure.
If the record classes differ, then the numerically greater class is
considered "lexicographically later".  Otherwise, if the record types
differ, then the numerically greater type is considered
"lexicographically later".  If the rrtype and rrclass both match,
then the rdata is compared.</p>
</div>
<div class="paragraph">
<p>In the case of resource records containing rdata that is subject to
name compression [<a href="#ref_RFC1035">RFC1035</a>], the names MUST be uncompressed before
comparison.  (The details of how a particular name is compressed is
an artifact of how and where the record is written into the DNS
message; it is not an intrinsic property of the resource record
itself.)</p>
</div>
<div class="paragraph">
<p>The bytes of the raw uncompressed rdata are compared in turn,
interpreting the bytes as eight-bit UNSIGNED values, until a byte is
found whose value is greater than that of its counterpart (in which
case, the rdata whose byte has the greater value is deemed
lexicographically later) or one of the resource records runs out of
rdata (in which case, the resource record which still has remaining
data first is deemed lexicographically later).  The following is an
example of a conflict:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>MyPrinter.local. A 169.254.99.200
MyPrinter.local. A 169.254.200.50</pre>
</div>
</div>
<div class="paragraph">
<p>In this case, 169.254.200.50 is lexicographically later (the third
byte, with value 200, is greater than its counterpart with value 99),
so it is deemed the winner.</p>
</div>
<div class="paragraph">
<p>Note that it is vital that the bytes are interpreted as UNSIGNED
values in the range 0-255, or the wrong outcome may result.  In the
example above, if the byte with value 200 had been incorrectly
interpreted as a signed eight-bit value, then it would be interpreted
as value -56, and the wrong address record would be deemed the
winner.</p>
</div>
<div class="sect3">
<h4 id="_simultaneous_probe_tiebreaking_for_multiple_records">8.2.1. Simultaneous Probe Tiebreaking for Multiple Records</h4>
<div class="paragraph">
<p>When a host is probing for a set of records with the same name, or a
message is received containing multiple tiebreaker records answering
a given probe question in the Question Section, the host&#8217;s records
and the tiebreaker records from the message are each sorted into
order, and then compared pairwise, using the same comparison
technique described above, until a difference is found.</p>
</div>
<div class="paragraph">
<p>The records are sorted using the same lexicographical order as
described above, that is, if the record classes differ, the record
with the lower class number comes first.  If the classes are the same
but the rrtypes differ, the record with the lower rrtype number comes
first.  If the class and rrtype match, then the rdata is compared
bytewise until a difference is found.  For example, in the common
case of advertising DNS-SD services with a TXT record and an SRV
record, the TXT record comes first (the rrtype value for TXT is 16)
and the SRV record comes second (the rrtype value for SRV is 33).</p>
</div>
<div class="paragraph">
<p>When comparing the records, if the first records match perfectly,
then the second records are compared, and so on.  If either list of
records runs out of records before any difference is found, then the
list with records remaining is deemed to have won the tiebreak.  If
both lists run out of records at the same time without any difference
being found, then this indicates that two devices are advertising
identical sets of records, as is sometimes done for fault tolerance,
and there is, in fact, no conflict.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_announcing">8.3. Announcing</h3>
<div class="paragraph">
<p>The second startup step is that the Multicast DNS responder MUST send
an unsolicited Multicast DNS response containing, in the Answer
Section, all of its newly registered resource records (both shared
records, and unique records that have completed the probing step).
If there are too many resource records to fit in a single packet,
multiple packets should be used.</p>
</div>
<div class="paragraph">
<p>In the case of shared records (e.g., the PTR records used by DNS-
Based Service Discovery [<a href="#ref_RFC6763">RFC6763</a>]), the records are simply placed as
is into the Answer Section of the DNS response.</p>
</div>
<div class="paragraph">
<p>In the case of records that have been verified to be unique in the
previous step, they are placed into the Answer Section of the DNS
response with the most significant bit of the rrclass set to one.
The most significant bit of the rrclass for a record in the Answer
Section of a response message is the Multicast DNS cache-flush bit
and is discussed in more detail below in Section <a href="#_announcements_to_flush_outdated_cache_entries">10.2</a>, "Announcements
to Flush Outdated Cache Entries".</p>
</div>
<div class="paragraph">
<p>The Multicast DNS responder MUST send at least two unsolicited
responses, one second apart.  To provide increased robustness against
packet loss, a responder MAY send up to eight unsolicited responses,
provided that the interval between unsolicited responses increases by
at least a factor of two with every response sent.</p>
</div>
<div class="paragraph">
<p>A Multicast DNS responder MUST NOT send announcements in the absence
of information that its network connectivity may have changed in some
relevant way.  In particular, a Multicast DNS responder MUST NOT send
regular periodic announcements as a matter of course.</p>
</div>
<div class="paragraph">
<p>Whenever a Multicast DNS responder receives any Multicast DNS
response (solicited or otherwise) containing a conflicting resource
record, the conflict MUST be resolved as described in Section<a href="#_conflict_resolution">9</a>,
"Conflict Resolution".</p>
</div>
</div>
<div class="sect2">
<h3 id="_updating">8.4. Updating</h3>
<div class="paragraph">
<p>At any time, if the rdata of any of a host&#8217;s Multicast DNS records
changes, the host MUST repeat the Announcing step described above to
update neighboring caches.  For example, if any of a host&#8217;s IP
addresses change, it MUST re-announce those address records.  The
host does not need to repeat the Probing step because it has already
established unique ownership of that name.</p>
</div>
<div class="paragraph">
<p>In the case of shared records, a host MUST send a "goodbye"
announcement with RR TTL zero (see Section <a href="#_goodbye_packets">10.1</a>, "Goodbye Packets")
for the old rdata, to cause it to be deleted from peer caches, before
announcing the new rdata.  In the case of unique records, a host
SHOULD omit the "goodbye" announcement, since the cache-flush bit on
the newly announced records will cause old rdata to be flushed from
peer caches anyway.</p>
</div>
<div class="paragraph">
<p>A host may update the contents of any of its records at any time,
though a host SHOULD NOT update records more frequently than ten
times per minute.  Frequent rapid updates impose a burden on the
network.  If a host has information to disseminate which changes more
frequently than ten times per minute, then it may be more appropriate
to design a protocol for that specific purpose.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conflict_resolution">9. Conflict Resolution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A conflict occurs when a Multicast DNS responder has a unique record
for which it is currently authoritative, and it receives a Multicast
DNS response message containing a record with the same name, rrtype
and rrclass, but inconsistent rdata.  What may be considered
inconsistent is context sensitive, except that resource records with
identical rdata are never considered inconsistent, even if they
originate from different hosts.  This is to permit use of proxies and
other fault-tolerance mechanisms that may cause more than one
responder to be capable of issuing identical answers on the network.</p>
</div>
<div class="paragraph">
<p>A common example of a resource record type that is intended to be
unique, not shared between hosts, is the address record that maps a
host&#8217;s name to its IP address.  Should a host witness another host
announce an address record with the same name but a different IP
address, then that is considered inconsistent, and that address
record is considered to be in conflict.</p>
</div>
<div class="paragraph">
<p>Whenever a Multicast DNS responder receives any Multicast DNS
response (solicited or otherwise) containing a conflicting resource
record in any of the Resource Record Sections, the Multicast DNS
responder MUST immediately reset its conflicted unique record to
probing state, and go through the startup steps described above in
Section <a href="#_probing_and_announcing_on_startup">8</a>, "Probing and Announcing on Startup".  The protocol used in
the Probing phase will determine a winner and a loser, and the loser
MUST cease using the name, and reconfigure.</p>
</div>
<div class="paragraph">
<p>It is very important that any host receiving a resource record that
conflicts with one of its own MUST take action as described above.
In the case of two hosts using the same host name, where one has been
configured to require a unique host name and the other has not, the
one that has not been configured to require a unique host name will
not perceive any conflict, and will not take any action.  By
reverting to Probing state, the host that desires a unique host name
will go through the necessary steps to ensure that a unique host name
is obtained.</p>
</div>
<div class="paragraph">
<p>The recommended course of action after probing and failing is as
follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Programmatically change the resource record name in an attempt
to find a new name that is unique.  This could be done by
adding some further identifying information (e.g., the model
name of the hardware) if it is not already present in the name,
or appending the digit "2" to the name, or incrementing a
number at the end of the name if one is already present.</p>
</li>
<li>
<p>Probe again, and repeat as necessary until a unique name is
found.</p>
</li>
<li>
<p>Once an available unique name has been determined, by probing
without receiving any conflicting response, record this newly
chosen name in persistent storage so that the device will use
the same name the next time it is power-cycled.</p>
</li>
<li>
<p>Display a message to the user or operator informing them of the
name change.  For example:</p>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>The name "Bob&#8217;s Music" is in use by another music server on
the network.  Your music collection has been renamed to
"Bob&#8217;s Music (2)".  If you want to change this name, use
[describe appropriate menu item or preference dialog here].</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The details of how the user or operator is informed of the new
name depends on context.  A desktop computer with a screen
might put up a dialog box.  A headless server in the closet may
write a message to a log file, or use whatever mechanism
(email, SNMP trap, etc.) it uses to inform the administrator of
error conditions.  On the other hand, a headless server in the
closet may not inform the user at all&#8201;&#8212;&#8201;if the user cares,
they will notice the name has changed, and connect to the
server in the usual way (e.g., via web browser) to configure a
new name.</p>
</div>
</li>
<li>
<p>After one minute of probing, if the Multicast DNS responder has
been unable to find any unused name, it should log an error
message to inform the user or operator of this fact.  This
situation should never occur in normal operation.  The only
situations that would cause this to happen would be either a
deliberate denial-of-service attack, or some kind of very
obscure hardware or software bug that acts like a deliberate
denial-of-service attack.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>These considerations apply to address records (i.e., host names) and
to all resource records where uniqueness (or maintenance of some
other defined constraint) is desired.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resource_record_ttl_values_and_cache_coherency">10. Resource Record TTL Values and Cache Coherency</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As a general rule, the recommended TTL value for Multicast DNS
resource records with a host name as the resource record&#8217;s name
(e.g., A, AAAA, HINFO) or a host name contained within the resource
record&#8217;s rdata (e.g., SRV, reverse mapping PTR record) SHOULD be 120
seconds.</p>
</div>
<div class="paragraph">
<p>The recommended TTL value for other Multicast DNS resource records is
75 minutes.</p>
</div>
<div class="paragraph">
<p>A querier with an active outstanding query will issue a query message
when one or more of the resource records in its cache are 80% of the
way to expiry.  If the TTL on those records is 75 minutes, this
ongoing cache maintenance process yields a steady-state query rate of
one query every 60 minutes.</p>
</div>
<div class="paragraph">
<p>Any distributed cache needs a cache coherency protocol.  If Multicast
DNS resource records follow the recommendation and have a TTL of 75
minutes, that means that stale data could persist in the system for a
little over an hour.  Making the default RR TTL significantly lower
would reduce the lifetime of stale data, but would produce too much
extra traffic on the network.  Various techniques are available to
minimize the impact of such stale data, outlined in the five
subsections below.</p>
</div>
<div class="sect2">
<h3 id="_goodbye_packets">10.1. Goodbye Packets</h3>
<div class="paragraph">
<p>In the case where a host knows that certain resource record data is
about to become invalid (for example, when the host is undergoing a
clean shutdown), the host SHOULD send an unsolicited Multicast DNS
response packet, giving the same resource record name, rrtype,
rrclass, and rdata, but an RR TTL of zero.  This has the effect of
updating the TTL stored in neighboring hosts' cache entries to zero,
causing that cache entry to be promptly deleted.</p>
</div>
<div class="paragraph">
<p>Queriers receiving a Multicast DNS response with a TTL of zero SHOULD
NOT immediately delete the record from the cache, but instead record
a TTL of 1 and then delete the record one second later.  In the case
of multiple Multicast DNS responders on the network described in
Section <a href="#_cooperating_multicast_dns_responders">6.6</a> above, if one of the responders shuts down and
incorrectly sends goodbye packets for its records, it gives the other
cooperating responders one second to send out their own response to
"rescue" the records before they expire and are deleted.</p>
</div>
</div>
<div class="sect2">
<h3 id="_announcements_to_flush_outdated_cache_entries">10.2. Announcements to Flush Outdated Cache Entries</h3>
<div class="paragraph">
<p>Whenever a host has a resource record with new data, or with what
might potentially be new data (e.g., after rebooting, waking from
sleep, connecting to a new network link, or changing IP address), the
host needs to inform peers of that new data.  In cases where the host
has not been continuously connected and participating on the network
link, it MUST first probe to re-verify uniqueness of its unique
records, as described above in Section <a href="#_probing">8.1</a>, "Probing".</p>
</div>
<div class="paragraph">
<p>Having completed the Probing step, if necessary, the host MUST then
send a series of unsolicited announcements to update cache entries in
its neighbor hosts.  In these unsolicited announcements, if the
record is one that has been verified unique, the host sets the most
significant bit of the rrclass field of the resource record.  This
bit, the cache-flush bit, tells neighboring hosts that this is not a
shared record type.  Instead of merging this new record additively
into the cache in addition to any previous records with the same
name, rrtype, and rrclass, all old records with that name, rrtype,
and rrclass that were received more than one second ago are declared
invalid, and marked to expire from the cache in one second.</p>
</div>
<div class="paragraph">
<p>The semantics of the cache-flush bit are as follows: normally when a
resource record appears in a Resource Record Section of the DNS
response it means, "This is an assertion that this information is
true".  When a resource record appears in a Resource Record Section
of the DNS response with the cache-flush bit set, it means, "This is
an assertion that this information is the truth and the whole truth,
and anything you may have heard more than a second ago regarding
records of this name/rrtype/rrclass is no longer true".</p>
</div>
<div class="paragraph">
<p>To accommodate the case where the set of records from one host
constituting a single unique RRSet is too large to fit in a single
packet, only cache records that are more than one second old are
flushed.  This allows the announcing host to generate a quick burst
of packets back-to-back on the wire containing all the members of the
RRSet.  When receiving records with the cache-flush bit set, all
records older than one second are marked to be deleted one second in
the future.  One second after the end of the little packet burst, any
records not represented within that packet burst will then be expired
from all peer caches.</p>
</div>
<div class="paragraph">
<p>Any time a host sends a response packet containing some members of a
unique RRSet, it MUST send the entire RRSet, preferably in a single
packet, or if the entire RRSet will not fit in a single packet, in a
quick burst of packets sent as close together as possible.  The host
MUST set the cache-flush bit on all members of the unique RRSet.</p>
</div>
<div class="paragraph">
<p>Another reason for waiting one second before deleting stale records
from the cache is to accommodate bridged networks.  For example, a
host&#8217;s address record announcement on a wireless interface may be
bridged onto a wired Ethernet and may cause that same host&#8217;s Ethernet
address records to be flushed from peer caches.  The one-second delay
gives the host the chance to see its own announcement arrive on the
wired Ethernet, and immediately re-announce its Ethernet interface&#8217;s
address records so that both sets remain valid and live in peer
caches.</p>
</div>
<div class="paragraph">
<p>These rules, about when to set the cache-flush bit and about sending
the entire rrset, apply regardless of <strong>why</strong> the response message is
being generated.  They apply to startup announcements as described in
Section <a href="#_announcing">8.3</a>, "Announcing", and to responses generated as a result of
receiving query messages.</p>
</div>
<div class="paragraph">
<p>The cache-flush bit is only set in records in the Resource Record
Sections of Multicast DNS responses sent to UDP port 5353.</p>
</div>
<div class="paragraph">
<p>The cache-flush bit MUST NOT be set in any resource records in a
response message sent in legacy unicast responses to UDP ports other
than 5353.</p>
</div>
<div class="paragraph">
<p>The cache-flush bit MUST NOT be set in any resource records in the
Known-Answer list of any query message.</p>
</div>
<div class="paragraph">
<p>The cache-flush bit MUST NOT ever be set in any shared resource
record.  To do so would cause all the other shared versions of this
resource record with different rdata from different responders to be
immediately deleted from all the caches on the network.</p>
</div>
<div class="paragraph">
<p>The cache-flush bit does <strong>not</strong> apply to questions listed in the
Question Section of a Multicast DNS message.  The top bit of the
rrclass field in questions is used for an entirely different purpose
(see Section <a href="#_questions_requesting_unicast_responses">5.4</a>, "Questions Requesting Unicast Responses").</p>
</div>
<div class="paragraph">
<p>Note that the cache-flush bit is NOT part of the resource record
class.  The cache-flush bit is the most significant bit of the second
16-bit word of a resource record in a Resource Record Section of a
Multicast DNS message (the field conventionally referred to as the
rrclass field), and the actual resource record class is the least
significant fifteen bits of this field.  There is no Multicast DNS
resource record class 0x8001.  The value 0x8001 in the rrclass field
of a resource record in a Multicast DNS response message indicates a
resource record with class 1, with the cache-flush bit set.  When
receiving a resource record with the cache-flush bit set,
implementations should take care to mask off that bit before storing
the resource record in memory, or otherwise ensure that it is given
the correct semantic interpretation.</p>
</div>
<div class="paragraph">
<p>The reuse of the top bit of the rrclass field only applies to
conventional resource record types that are subject to caching, not
to pseudo-RRs like OPT [<a href="#ref_RFC2671">RFC2671</a>], TSIG [<a href="#ref_RFC2845">RFC2845</a>], TKEY [<a href="#ref_RFC2930">RFC2930</a>],
SIG0 [<a href="#ref_RFC2931">RFC2931</a>], etc., that pertain only to a particular transport
level message and not to any actual DNS data.  Since pseudo-RRs
should never go into the Multicast DNS cache, the concept of a cache-
flush bit for these types is not applicable.  In particular, the
rrclass field of an OPT record encodes the sender&#8217;s UDP payload size,
and should be interpreted as a sixteen-bit length value in the range
0-65535, not a one-bit flag and a fifteen-bit length.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cache_flush_on_topology_change">10.3. Cache Flush on Topology change</h3>
<div class="paragraph">
<p>If the hardware on a given host is able to indicate physical changes
of connectivity, then when the hardware indicates such a change, the
host should take this information into account in its Multicast DNS
cache management strategy.  For example, a host may choose to
immediately flush all cache records received on a particular
interface when that cable is disconnected.  Alternatively, a host may
choose to adjust the remaining TTL on all those records to a few
seconds so that if the cable is not reconnected quickly, those
records will expire from the cache.</p>
</div>
<div class="paragraph">
<p>Likewise, when a host reboots, wakes from sleep, or undergoes some
other similar discontinuous state change, the cache management
strategy should take that information into account.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cache_flush_on_failure_indication">10.4. Cache Flush on Failure Indication</h3>
<div class="paragraph">
<p>Sometimes a cache record can be determined to be stale when a client
attempts to use the rdata it contains, and the client finds that
rdata to be incorrect.</p>
</div>
<div class="paragraph">
<p>For example, the rdata in an address record can be determined to be
incorrect if attempts to contact that host fail, either because (for
an IPv4 address on a local subnet) ARP requests for that address go
unanswered, because (for an IPv6 address with an on-link prefix) ND
requests for that address go unanswered, or because (for an address
on a remote network) a router returns an ICMP "Host Unreachable"
error.</p>
</div>
<div class="paragraph">
<p>The rdata in an SRV record can be determined to be incorrect if
attempts to communicate with the indicated service at the host and
port number indicated are not successful.</p>
</div>
<div class="paragraph">
<p>The rdata in a DNS-SD PTR record can be determined to be incorrect if
attempts to look up the SRV record it references are not successful.</p>
</div>
<div class="paragraph">
<p>The software implementing the Multicast DNS resource record cache
should provide a mechanism so that clients detecting stale rdata can
inform the cache.</p>
</div>
<div class="paragraph">
<p>When the cache receives this hint that it should reconfirm some
record, it MUST issue two or more queries for the resource record in
dispute.  If no response is received within ten seconds, then, even
though its TTL may indicate that it is not yet due to expire, that
record SHOULD be promptly flushed from the cache.</p>
</div>
<div class="paragraph">
<p>The end result of this is that if a printer suffers a sudden power
failure or other abrupt disconnection from the network, its name may
continue to appear in DNS-SD browser lists displayed on users'
screens.  Eventually, that entry will expire from the cache
naturally, but if a user tries to access the printer before that
happens, the failure to successfully contact the printer will trigger
the more hasty demise of its cache entries.  This is a sensible
trade-off between good user experience and good network efficiency.
If we were to insist that printers should disappear from the printer
list within 30 seconds of becoming unavailable, for all failure
modes, the only way to achieve this would be for the client to poll
the printer at least every 30 seconds, or for the printer to announce
its presence at least every 30 seconds, both of which would be an
unreasonable burden on most networks.</p>
</div>
</div>
<div class="sect2">
<h3 id="_passive_observation_of_failures_poof">10.5. Passive Observation Of Failures (POOF)</h3>
<div class="paragraph">
<p>A host observes the multicast queries issued by the other hosts on
the network.  One of the major benefits of also sending responses
using multicast is that it allows all hosts to see the responses (or
lack thereof) to those queries.</p>
</div>
<div class="paragraph">
<p>If a host sees queries, for which a record in its cache would be
expected to be given as an answer in a multicast response, but no
such answer is seen, then the host may take this as an indication
that the record may no longer be valid.</p>
</div>
<div class="paragraph">
<p>After seeing two or more of these queries, and seeing no multicast
response containing the expected answer within ten seconds, then even
though its TTL may indicate that it is not yet due to expire, that
record SHOULD be flushed from the cache.  The host SHOULD NOT perform
its own queries to reconfirm that the record is truly gone.  If every
host on a large network were to do this, it would cause a lot of
unnecessary multicast traffic.  If host A sends multicast queries
that remain unanswered, then there is no reason to suppose that host
B or any other host is likely to be any more successful.</p>
</div>
<div class="paragraph">
<p>The previous section, "Cache Flush on Failure Indication", describes
a situation where a user trying to print discovers that the printer
is no longer available.  By implementing the passive observation
described here, when one user fails to contact the printer, all hosts
on the network observe that failure and update their caches
accordingly.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_address_check">11. Source Address Check</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All Multicast DNS responses (including responses sent via unicast)
SHOULD be sent with IP TTL set to 255.  This is recommended to
provide backwards-compatibility with older Multicast DNS queriers
(implementing a draft version of this document, posted in February
2004) that check the IP TTL on reception to determine whether the
packet originated on the local link.  These older queriers discard
all packets with TTLs other than 255.</p>
</div>
<div class="paragraph">
<p>A host sending Multicast DNS queries to a link-local destination
address (including the 224.0.0.251 and FF02::FB link-local multicast
addresses) MUST only accept responses to that query that originate
from the local link, and silently discard any other response packets.
Without this check, it could be possible for remote rogue hosts to
send spoof answer packets (perhaps unicast to the victim host), which
the receiving machine could misinterpret as having originated on the
local link.</p>
</div>
<div class="paragraph">
<p>The test for whether a response originated on the local link is done
in two ways:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>All responses received with a destination address in the IP
header that is the mDNS IPv4 link-local multicast address
224.0.0.251 or the mDNS IPv6 link-local multicast address
FF02::FB are necessarily deemed to have originated on the local
link, regardless of source IP address.  This is essential to
allow devices to work correctly and reliably in unusual
configurations, such as multiple logical IP subnets overlayed on
a single link, or in cases of severe misconfiguration, where
devices are physically connected to the same link, but are
currently misconfigured with completely unrelated IP addresses
and subnet masks.</p>
</li>
<li>
<p>For responses received with a unicast destination address in the
IP header, the source IP address in the packet is checked to see
if it is an address on a local subnet.  An IPv4 source address
is determined to be on a local subnet if, for (one of) the
address(es) configured on the interface receiving the packet, (I
&amp; M) == (P &amp; M), where I and M are the interface address and
subnet mask respectively, P is the source IP address from the
packet, '&amp;' represents the bitwise logical 'and' operation, and
'==' represents a bitwise equality test.  An IPv6 source address
is determined to be on the local link if, for any of the on-link
IPv6 prefixes on the interface receiving the packet (learned via
IPv6 router advertisements or otherwise configured on the host),
the first 'n' bits of the IPv6 source address match the first
'n' bits of the prefix address, where 'n' is the length of the
prefix being considered.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Since queriers will ignore responses apparently originating outside
the local subnet, a responder SHOULD avoid generating responses that
it can reasonably predict will be ignored.  This applies particularly
in the case of overlayed subnets.  If a responder receives a query
addressed to the mDNS IPv4 link-local multicast address 224.0.0.251,
from a source address not apparently on the same subnet as the
responder (or, in the case of IPv6, from a source IPv6 address for
which the responder does not have any address with the same prefix on
that interface), then even if the query indicates that a unicast
response is preferred (see Section <a href="#_questions_requesting_unicast_responses">5.4</a>, "Questions Requesting Unicast
Responses"), the responder SHOULD elect to respond by multicast
anyway, since it can reasonably predict that a unicast response with
an apparently non-local source address will probably be ignored.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_special_characteristics_of_multicast_dns_domains">12. Special Characteristics of Multicast DNS Domains</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unlike conventional DNS names, names that end in ".local." have only
local significance.  The same is true of names within the IPv4 link-
local reverse mapping domain "254.169.in-addr.arpa." and the IPv6
link-local reverse mapping domains "8.e.f.ip6.arpa.",
"9.e.f.ip6.arpa.", "a.e.f.ip6.arpa.", and "b.e.f.ip6.arpa.".</p>
</div>
<div class="paragraph">
<p>These names function primarily as protocol identifiers, rather than
as user-visible identifiers.  Even though they may occasionally be
visible to end users, that is not their primary purpose.  As such,
these names should be treated as opaque identifiers.  In particular,
the string "local" should not be translated or localized into
different languages, much as the name "localhost" is not translated
or localized into different languages.</p>
</div>
<div class="paragraph">
<p>Conventional Unicast DNS seeks to provide a single unified namespace,
where a given DNS query yields the same answer no matter where on the
planet it is performed or to which recursive DNS server the query is
sent.  In contrast, each IP link has its own private ".local.",
"254.169.in-addr.arpa." and IPv6 link-local reverse mapping
namespaces, and the answer to any query for a name within those
domains depends on where that query is asked.  (This characteristic
is not unique to Multicast DNS.  Although the original concept of DNS
was a single global namespace, in recent years, split views,
firewalls, intranets, DNS geolocation, and the like have increasingly
meant that the answer to a given DNS query has become dependent on
the location of the querier.)</p>
</div>
<div class="paragraph">
<p>The IPv4 name server address for a Multicast DNS domain is
224.0.0.251.  The IPv6 name server address for a Multicast DNS domain
is FF02::FB.  These are multicast addresses; therefore, they identify
not a single host but a collection of hosts, working in cooperation
to maintain some reasonable facsimile of a competently managed DNS
zone.  Conceptually, a Multicast DNS domain is a single DNS zone;
however, its server is implemented as a distributed process running
on a cluster of loosely cooperating CPUs rather than as a single
process running on a single CPU.</p>
</div>
<div class="paragraph">
<p>Multicast DNS domains are not delegated from their parent domain via
use of NS (Name Server) records, and there is also no concept of
delegation of subdomains within a Multicast DNS domain.  Just because
a particular host on the network may answer queries for a particular
record type with the name "example.local." does not imply anything
about whether that host will answer for the name
"child.example.local.", or indeed for other record types with the
name "example.local.".</p>
</div>
<div class="paragraph">
<p>There are no NS records anywhere in Multicast DNS domains.  Instead,
the Multicast DNS domains are reserved by IANA, and there is
effectively an implicit delegation of all Multicast DNS domains to
the 224.0.0.251:5353 and [FF02::FB]:5353 multicast groups, by virtue
of client software implementing the protocol rules specified in this
document.</p>
</div>
<div class="paragraph">
<p>Multicast DNS zones have no SOA (Start of Authority) record.  A
conventional DNS zone&#8217;s SOA record contains information such as the
email address of the zone administrator and the monotonically
increasing serial number of the last zone modification.  There is no
single human administrator for any given Multicast DNS zone, so there
is no email address.  Because the hosts managing any given Multicast
DNS zone are only loosely coordinated, there is no readily available
monotonically increasing serial number to determine whether or not
the zone contents have changed.  A host holding part of the shared
zone could crash or be disconnected from the network at any time
without informing the other hosts.  There is no reliable way to
provide a zone serial number that would, whenever such a crash or
disconnection occurred, immediately change to indicate that the
contents of the shared zone had changed.</p>
</div>
<div class="paragraph">
<p>Zone transfers are not possible for any Multicast DNS zone.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_enabling_and_disabling_multicast_dns">13. Enabling and Disabling Multicast DNS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The option to fail-over to Multicast DNS for names not ending in
".local." SHOULD be a user-configured option, and SHOULD be disabled
by default because of the possible security issues related to
unintended local resolution of apparently global names.  Enabling
Multicast DNS for names not ending in ".local." may be appropriate on
a secure isolated network, or on some future network were machines
exclusively use DNSSEC for all DNS queries, and have Multicast DNS
responders capable of generating the appropriate cryptographic DNSSEC
signatures, thereby guarding against spoofing.</p>
</div>
<div class="paragraph">
<p>The option to look up unqualified (relative) names by appending
".local." (or not) is controlled by whether ".local." appears (or
not) in the client&#8217;s DNS search list.</p>
</div>
<div class="paragraph">
<p>No special control is needed for enabling and disabling Multicast DNS
for names explicitly ending with ".local." as entered by the user.
The user doesn&#8217;t need a way to disable Multicast DNS for names ending
with ".local.", because if the user doesn&#8217;t want to use Multicast
DNS, they can achieve this by simply not using those names.  If a
user <strong>does</strong> enter a name ending in ".local.", then we can safely
assume the user&#8217;s intention was probably that it should work.  Having
user configuration options that can be (intentionally or
unintentionally) set so that local names don&#8217;t work is just one more
way of frustrating the user&#8217;s ability to perform the tasks they want,
perpetuating the view that, "IP networking is too complicated to
configure and too hard to use".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_considerations_for_multiple_interfaces">14. Considerations for Multiple Interfaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A host SHOULD defend its dot-local host name on all active interfaces
on which it is answering Multicast DNS queries.</p>
</div>
<div class="paragraph">
<p>In the event of a name conflict on <strong>any</strong> interface, a host should
configure a new host name, if it wishes to maintain uniqueness of its
host name.</p>
</div>
<div class="paragraph">
<p>A host may choose to use the same name (or set of names) for all of
its address records on all interfaces, or it may choose to manage its
Multicast DNS interfaces independently, potentially answering to a
different name (or set of names) on different interfaces.</p>
</div>
<div class="paragraph">
<p>Except in the case of proxying and other similar specialized uses,
addresses in IPv4 or IPv6 address records in Multicast DNS responses
MUST be valid for use on the interface on which the response is being
sent.</p>
</div>
<div class="paragraph">
<p>Just as the same link-local IP address may validly be in use
simultaneously on different links by different hosts, the same link-
local host name may validly be in use simultaneously on different
links, and this is not an error.  A multihomed host with connections
to two different links may be able to communicate with two different
hosts that are validly using the same name.  While this kind of name
duplication should be rare, it means that a host that wants to fully
support this case needs network programming APIs that allow
applications to specify on what interface to perform a link-local
Multicast DNS query, and to discover on what interface a Multicast
DNS response was received.</p>
</div>
<div class="paragraph">
<p>There is one other special precaution that multihomed hosts need to
take.  It&#8217;s common with today&#8217;s laptop computers to have an Ethernet
connection and an 802.11 [<a href="#ref_IEEE.802.11">IEEE.802.11</a>] wireless connection active at
the same time.  What the software on the laptop computer can&#8217;t easily
tell is whether the wireless connection is in fact bridged onto the
same network segment as its Ethernet connection.  If the two networks
are bridged together, then packets the host sends on one interface
will arrive on the other interface a few milliseconds later, and care
must be taken to ensure that this bridging does not cause problems:</p>
</div>
<div class="paragraph">
<p>When the host announces its host name (i.e., its address records) on
its wireless interface, those announcement records are sent with the
cache-flush bit set, so when they arrive on the Ethernet segment,
they will cause all the peers on the Ethernet to flush the host&#8217;s
Ethernet address records from their caches.  The Multicast DNS
protocol has a safeguard to protect against this situation: when
records are received with the cache-flush bit set, other records are
not deleted from peer caches immediately, but are marked for deletion
in one second.  When the host sees its own wireless address records
arrive on its Ethernet interface, with the cache-flush bit set, this
one-second grace period gives the host time to respond and re-
announce its Ethernet address records, to reinstate those records in
peer caches before they are deleted.</p>
</div>
<div class="paragraph">
<p>As described, this solves one problem, but creates another, because
when those Ethernet announcement records arrive back on the wireless
interface, the host would again respond defensively to reinstate its
wireless records, and this process would continue forever,
continuously flooding the network with traffic.  The Multicast DNS
protocol has a second safeguard, to solve this problem: the cache-
flush bit does not apply to records received very recently, within
the last second.  This means that when the host sees its own Ethernet
address records arrive on its wireless interface, with the cache-
flush bit set, it knows there&#8217;s no need to re-announce its wireless
address records again because it already sent them less than a second
ago, and this makes them immune from deletion from peer caches.  (See
Section <a href="#_announcements_to_flush_outdated_cache_entries">10.2</a>.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_considerations_for_multiple_responders_on_the_same_machine">15. Considerations for Multiple Responders on the Same Machine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is possible to have more than one Multicast DNS responder and/or
querier implementation coexist on the same machine, but there are
some known issues.</p>
</div>
<div class="sect2">
<h3 id="_receiving_unicast_responses">15.1. Receiving Unicast Responses</h3>
<div class="paragraph">
<p>In most operating systems, incoming <strong>multicast</strong> packets can be
delivered to <strong>all</strong> open sockets bound to the right port number,
provided that the clients take the appropriate steps to allow this.
For this reason, all Multicast DNS implementations SHOULD use the
SO_REUSEPORT and/or SO_REUSEADDR options (or equivalent as
appropriate for the operating system in question) so they will all be
able to bind to UDP port 5353 and receive incoming multicast packets
addressed to that port.  However, unlike multicast packets, incoming
unicast UDP packets are typically delivered only to the first socket
to bind to that port.  This means that "QU" responses and other
packets sent via unicast will be received only by the first Multicast
DNS responder and/or querier on a system.  This limitation can be
partially mitigated if Multicast DNS implementations detect when they
are not the first to bind to port 5353, and in that case they do not
request "QU" responses.  One way to detect if there is another
Multicast DNS implementation already running is to attempt binding to
port 5353 without using SO_REUSEPORT and/or SO_REUSEADDR, and if that
fails it indicates that some other socket is already bound to this
port.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multipacket_known_answer_lists">15.2. Multipacket Known-Answer lists</h3>
<div class="paragraph">
<p>When a Multicast DNS querier issues a query with too many Known
Answers to fit into a single packet, it divides the Known-Answer list
into two or more packets.  Multicast DNS responders associate the
initial truncated query with its continuation packets by examining
the source IP address in each packet.  Since two independent
Multicast DNS queriers running on the same machine will be sending
packets with the same source IP address, from an outside perspective
they appear to be a single entity.  If both queriers happened to send
the same multipacket query at the same time, with different Known-
Answer lists, then they could each end up suppressing answers that
the other needs.</p>
</div>
</div>
<div class="sect2">
<h3 id="_efficiency">15.3. Efficiency</h3>
<div class="paragraph">
<p>If different clients on a machine were each to have their own
independent Multicast DNS implementation, they would lose certain
efficiency benefits.  Apart from the unnecessary code duplication,
memory usage, and CPU load, the clients wouldn&#8217;t get the benefit of a
shared system-wide cache, and they would not be able to aggregate
separate queries into single packets to reduce network traffic.</p>
</div>
</div>
<div class="sect2">
<h3 id="_recommendation">15.4. Recommendation</h3>
<div class="paragraph">
<p>Because of these issues, this document encourages implementers to
design systems with a single Multicast DNS implementation that
provides Multicast DNS services shared by all clients on that
machine, much as most operating systems today have a single TCP
implementation, which is shared between all clients on that machine.
Due to engineering constraints, there may be situations where
embedding a "user-level" Multicast DNS implementation in the client
application software is the most expedient solution, and while this
will usually work in practice, implementers should be aware of the
issues outlined in this section.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multicast_dns_character_set">16. Multicast DNS Character Set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Historically, Unicast DNS has been used with a very restricted set of
characters.  Indeed, conventional DNS is usually limited to just
twenty-six letters, ten digits and the hyphen character, not even
allowing spaces or other punctuation.  Attempts to remedy this for
Unicast DNS have been badly constrained by the perceived need to
accommodate old buggy legacy DNS implementations.  In reality, the
DNS specification itself actually imposes no limits on what
characters may be used in names, and good DNS implementations handle
any arbitrary eight-bit data without trouble.  "Clarifications to the
DNS Specification" [<a href="#ref_RFC2181">RFC2181</a>] directly discusses the subject of
allowable character set in Section 11 ("Name syntax"), and explicitly
states that DNS names may contain arbitrary eight-bit data.  However,
the old rules for ARPANET host names back in the 1980s required host
names to be just letters, digits, and hyphens [<a href="#ref_RFC1034">RFC1034</a>], and since
the predominant use of DNS is to store host address records, many
have assumed that the DNS protocol itself suffers from the same
limitation.  It might be accurate to say that there could be
hypothetical bad implementations that do not handle eight-bit data
correctly, but it would not be accurate to say that the protocol
doesn&#8217;t allow names containing eight-bit data.</p>
</div>
<div class="paragraph">
<p>Multicast DNS is a new protocol and doesn&#8217;t (yet) have old buggy
legacy implementations to constrain the design choices.  Accordingly,
it adopts the simple obvious elegant solution: all names in Multicast
DNS MUST be encoded as precomposed UTF-8 [<a href="#ref_RFC3629">RFC3629</a>] "Net-Unicode"
[<a href="#ref_RFC5198">RFC5198</a>] text.</p>
</div>
<div class="paragraph">
<p>Some users of 16-bit Unicode have taken to stuffing a "zero-width
nonbreaking space" character (U+FEFF) at the start of each UTF-16
file, as a hint to identify whether the data is big-endian or little-
endian, and calling it a "Byte Order Mark" (BOM).  Since there is
only one possible byte order for UTF-8 data, a BOM is neither
necessary nor permitted.  Multicast DNS names MUST NOT contain a
"Byte Order Mark".  Any occurrence of the Unicode character U+FEFF at
the start or anywhere else in a Multicast DNS name MUST be
interpreted as being an actual intended part of the name,
representing (just as for any other legal unicode value) an actual
literal instance of that character (in this case a zero-width non-
breaking space character).</p>
</div>
<div class="paragraph">
<p>For names that are restricted to US-ASCII [<a href="#ref_RFC0020">RFC0020</a>] letters, digits,
and hyphens, the UTF-8 encoding is identical to the US-ASCII
encoding, so this is entirely compatible with existing host names.
For characters outside the US-ASCII range, UTF-8 encoding is used.</p>
</div>
<div class="paragraph">
<p>Multicast DNS implementations MUST NOT use any other encodings apart
from precomposed UTF-8 (US-ASCII being considered a compatible subset
of UTF-8).  The reasons for selecting UTF-8 instead of Punycode
[<a href="#ref_RFC3492">[ref_RFC3492]</a>] are discussed further in <a href="#appendix_F">Appendix F</a>.</p>
</div>
<div class="paragraph">
<p>The simple rules for case-insensitivity in Unicast DNS [<a href="#ref_RFC1034">RFC1034</a>]
[<a href="#ref_RFC1035">RFC1035</a>] also apply in Multicast DNS; that is to say, in name
comparisons, the lowercase letters "a" to "z" (0x61 to 0x7A) match
their uppercase equivalents "A" to "Z" (0x41 to 0x5A).  Hence, if a
querier issues a query for an address record with the name
"myprinter.local.", then a responder having an address record with
the name "MyPrinter.local." should issue a response.  No other
automatic equivalences should be assumed.  In particular, all UTF-8
multibyte characters (codes 0x80 and higher) are compared by simple
binary comparison of the raw byte values.  Accented characters are
<strong>not</strong> defined to be automatically equivalent to their unaccented
counterparts.  Where automatic equivalences are desired, this may be
achieved through the use of programmatically generated CNAME records.
For example, if a responder has an address record for an accented
name Y, and a querier issues a query for a name X, where X is the
same as Y with all the accents removed, then the responder may issue
a response containing two resource records: a CNAME record "X CNAME
Y", asserting that the requested name X (unaccented) is an alias for
the true (accented) name Y, followed by the address record for Y.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multicast_dns_message_size">17. Multicast DNS Message Size</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The 1987 DNS specification [<a href="#ref_RFC1035">RFC1035</a>] restricts DNS messages carried
by UDP to no more than 512 bytes (not counting the IP or UDP
headers).  For UDP packets carried over the wide-area Internet in
1987, this was appropriate.  For link-local multicast packets on
today&#8217;s networks, there is no reason to retain this restriction.
Given that the packets are by definition link-local, there are no
Path MTU issues to consider.</p>
</div>
<div class="paragraph">
<p>Multicast DNS messages carried by UDP may be up to the IP MTU of the
physical interface, less the space required for the IP header (20
bytes for IPv4; 40 bytes for IPv6) and the UDP header (8 bytes).</p>
</div>
<div class="paragraph">
<p>In the case of a single Multicast DNS resource record that is too
large to fit in a single MTU-sized multicast response packet, a
Multicast DNS responder SHOULD send the resource record alone, in a
single IP datagram, using multiple IP fragments.  Resource records
this large SHOULD be avoided, except in the very rare cases where
they really are the appropriate solution to the problem at hand.
Implementers should be aware that many simple devices do not
reassemble fragmented IP datagrams, so large resource records SHOULD
NOT be used except in specialized cases where the implementer knows
that all receivers implement reassembly, or where the large resource
record contains optional data which is not essential for correct
operation of the client.</p>
</div>
<div class="paragraph">
<p>A Multicast DNS packet larger than the interface MTU, which is sent
using fragments, MUST NOT contain more than one resource record.</p>
</div>
<div class="paragraph">
<p>Even when fragmentation is used, a Multicast DNS packet, including IP
and UDP headers, MUST NOT exceed 9000 bytes.</p>
</div>
<div class="paragraph">
<p>Note that 9000 bytes is also the maximum payload size of an Ethernet
"Jumbo" packet [<a href="#ref_Jumbo">Jumbo</a>].  However, in practice Ethernet "Jumbo"
packets are not widely used, so it is advantageous to keep packets
under 1500 bytes whenever possible.  Even on hosts that normally
handle Ethernet "Jumbo" packets and IP fragment reassembly, it is
becoming more common for these hosts to implement power-saving modes
where the main CPU goes to sleep and hands off packet reception tasks
to a more limited processor in the network interface hardware, which
may not support Ethernet "Jumbo" packets or IP fragment reassembly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multicast_dns_message_format">18. Multicast DNS Message Format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes specific rules pertaining to the allowable
values for the header fields of a Multicast DNS message, and other
message format considerations.</p>
</div>
<div class="sect2">
<h3 id="_id_query_identifier">18.1. ID (Query Identifier)</h3>
<div class="paragraph">
<p>Multicast DNS implementations SHOULD listen for unsolicited responses
issued by hosts booting up (or waking up from sleep or otherwise
joining the network).  Since these unsolicited responses may contain
a useful answer to a question for which the querier is currently
awaiting an answer, Multicast DNS implementations SHOULD examine all
received Multicast DNS response messages for useful answers, without
regard to the contents of the ID field or the Question Section.  In
Multicast DNS, knowing which particular query message (if any) is
responsible for eliciting a particular response message is less
interesting than knowing whether the response message contains useful
information.</p>
</div>
<div class="paragraph">
<p>Multicast DNS implementations MAY cache data from any or all
Multicast DNS response messages they receive, for possible future
use, provided of course that normal TTL aging is performed on these
cached resource records.</p>
</div>
<div class="paragraph">
<p>In multicast query messages, the Query Identifier SHOULD be set to
zero on transmission.</p>
</div>
<div class="paragraph">
<p>In multicast responses, including unsolicited multicast responses,
the Query Identifier MUST be set to zero on transmission, and MUST be
ignored on reception.</p>
</div>
<div class="paragraph">
<p>In legacy unicast response messages generated specifically in
response to a particular (unicast or multicast) query, the Query
Identifier MUST match the ID from the query message.</p>
</div>
</div>
<div class="sect2">
<h3 id="_qr_queryresponse_bit">18.2. QR (Query/Response) Bit</h3>
<div class="paragraph">
<p>In query messages the QR bit MUST be zero.
In response messages the QR bit MUST be one.</p>
</div>
</div>
<div class="sect2">
<h3 id="_opcode">18.3. OPCODE</h3>
<div class="paragraph">
<p>In both multicast query and multicast response messages, the OPCODE
MUST be zero on transmission (only standard queries are currently
supported over multicast).  Multicast DNS messages received with an
OPCODE other than zero MUST be silently ignored.</p>
</div>
</div>
<div class="sect2">
<h3 id="_aa_authoritative_answer_bit">18.4. AA (Authoritative Answer) Bit</h3>
<div class="paragraph">
<p>In query messages, the Authoritative Answer bit MUST be zero on
transmission, and MUST be ignored on reception.</p>
</div>
<div class="paragraph">
<p>In response messages for Multicast domains, the Authoritative Answer
bit MUST be set to one (not setting this bit would imply there&#8217;s some
other place where "better" information may be found) and MUST be
ignored on reception.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tc_truncated_bit">18.5. TC (Truncated) Bit</h3>
<div class="paragraph">
<p>In query messages, if the TC bit is set, it means that additional
Known-Answer records may be following shortly.  A responder SHOULD
record this fact, and wait for those additional Known-Answer records,
before deciding whether to respond.  If the TC bit is clear, it means
that the querying host has no additional Known Answers.</p>
</div>
<div class="paragraph">
<p>In multicast response messages, the TC bit MUST be zero on
transmission, and MUST be ignored on reception.</p>
</div>
<div class="paragraph">
<p>In legacy unicast response messages, the TC bit has the same meaning
as in conventional Unicast DNS: it means that the response was too
large to fit in a single packet, so the querier SHOULD reissue its
query using TCP in order to receive the larger response.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rd_recursion_desired_bit">18.6. RD (Recursion Desired) Bit</h3>
<div class="paragraph">
<p>In both multicast query and multicast response messages, the
Recursion Desired bit SHOULD be zero on transmission, and MUST be
ignored on reception.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ra_recursion_available_bit">18.7. RA (Recursion Available) Bit</h3>
<div class="paragraph">
<p>In both multicast query and multicast response messages, the
Recursion Available bit MUST be zero on transmission, and MUST be
ignored on reception.</p>
</div>
</div>
<div class="sect2">
<h3 id="_z_zero_bit">18.8. Z (Zero) Bit</h3>
<div class="paragraph">
<p>In both query and response messages, the Zero bit MUST be zero on
transmission, and MUST be ignored on reception.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ad_authentic_data_bit">18.9. AD (Authentic Data) Bit</h3>
<div class="paragraph">
<p>In both multicast query and multicast response messages, the
Authentic Data bit [<a href="#ref_RFC2535">RFC2535</a>] MUST be zero on transmission, and MUST
be ignored on reception.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cd_checking_disabled_bit">18.10. CD (Checking Disabled) Bit</h3>
<div class="paragraph">
<p>In both multicast query and multicast response messages, the Checking
Disabled bit [<a href="#ref_RFC2535">RFC2535</a>] MUST be zero on transmission, and MUST be
ignored on reception.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rcode_response_code">18.11. RCODE (Response Code)</h3>
<div class="paragraph">
<p>In both multicast query and multicast response messages, the Response
Code MUST be zero on transmission.  Multicast DNS messages received
with non-zero Response Codes MUST be silently ignored.</p>
</div>
</div>
<div class="sect2">
<h3 id="_repurposing_of_top_bit_of_qclass_in_question_section">18.12. Repurposing of Top Bit of qclass in Question Section</h3>
<div class="paragraph">
<p>In the Question Section of a Multicast DNS query, the top bit of the
qclass field is used to indicate that unicast responses are preferred
for this particular question.  (See Section <a href="#_questions_requesting_unicast_responses">5.4</a>.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_repurposing_of_top_bit_of_rrclass_in_resource_record_sections">18.13. Repurposing of Top Bit of rrclass in Resource Record Sections</h3>
<div class="paragraph">
<p>In the Resource Record Sections of a Multicast DNS response, the top
bit of the rrclass field is used to indicate that the record is a
member of a unique RRSet, and the entire RRSet has been sent together
(in the same packet, or in consecutive packets if there are too many
records to fit in a single packet).  (See Section <a href="#_announcements_to_flush_outdated_cache_entries">10.2</a>.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_name_compression">18.14. Name Compression</h3>
<div class="paragraph">
<p>When generating Multicast DNS messages, implementations SHOULD use
name compression wherever possible to compress the names of resource
records, by replacing some or all of the resource record name with a
compact two-byte reference to an appearance of that data somewhere
earlier in the message [<a href="#ref_RFC1035">RFC1035</a>].</p>
</div>
<div class="paragraph">
<p>This applies not only to Multicast DNS responses, but also to
queries.  When a query contains more than one question, successive
questions in the same message often contain similar names, and
consequently name compression SHOULD be used, to save bytes.  In
addition, queries may also contain Known Answers in the Answer
Section, or probe tiebreaking data in the Authority Section, and
these names SHOULD similarly be compressed for network efficiency.</p>
</div>
<div class="paragraph">
<p>In addition to compressing the <strong>names</strong> of resource records, names
that appear within the <strong>rdata</strong> of the following rrtypes SHOULD also
be compressed in all Multicast DNS messages:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>NS, CNAME, PTR, DNAME, SOA, MX, AFSDB, RT, KX, RP, PX, SRV, NSEC</pre>
</div>
</div>
<div class="paragraph">
<p>Until future IETF Standards Action [<a href="#ref_RFC5226">RFC5226</a>] specifying that names in
the rdata of other types should be compressed, names that appear
within the rdata of any type not listed above MUST NOT be compressed.</p>
</div>
<div class="paragraph">
<p>Implementations receiving Multicast DNS messages MUST correctly
decode compressed names appearing in the Question Section, and
compressed names of resource records appearing in other sections.</p>
</div>
<div class="paragraph">
<p>In addition, implementations MUST correctly decode compressed names
appearing within the <strong>rdata</strong> of the rrtypes listed above.  Where
possible, implementations SHOULD also correctly decode compressed
names appearing within the <strong>rdata</strong> of other rrtypes known to the
implementers at the time of implementation, because such forward-
thinking planning helps facilitate the deployment of future
implementations that may have reason to compress those rrtypes.  It
is possible that no future IETF Standards Action [<a href="#ref_RFC5226">RFC5226</a>] will be
created that mandates or permits the compression of rdata in new
types, but having implementations designed such that they are capable
of decompressing all known types helps keep future options open.</p>
</div>
<div class="paragraph">
<p>One specific difference between Unicast DNS and Multicast DNS is that
Unicast DNS does not allow name compression for the target host in an
SRV record, because Unicast DNS implementations before the first SRV
specification in 1996 [<a href="#ref_RFC2052">RFC2052</a>] may not decode these compressed
records properly.  Since all Multicast DNS implementations were
created after 1996, all Multicast DNS implementations are REQUIRED to
decode compressed SRV records correctly.</p>
</div>
<div class="paragraph">
<p>In legacy unicast responses generated to answer legacy queries, name
compression MUST NOT be performed on SRV records.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary_of_differences_between_multicast_dns_and_unicast_dns">19. Summary of Differences between Multicast DNS and Unicast DNS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multicast DNS shares, as much as possible, the familiar APIs, naming
syntax, resource record types, etc., of Unicast DNS.  There are, of
course, necessary differences by virtue of it using multicast, and by
virtue of it operating in a community of cooperating peers, rather
than a precisely defined hierarchy controlled by a strict chain of
formal delegations from the root.  These differences are summarized
below:</p>
</div>
<div class="paragraph">
<p>Multicast DNS&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>uses multicast</p>
</li>
<li>
<p>uses UDP port 5353 instead of port 53</p>
</li>
<li>
<p>operates in well-defined parts of the DNS namespace</p>
</li>
<li>
<p>has no SOA (Start of Authority) records</p>
</li>
<li>
<p>uses UTF-8, and only UTF-8, to encode resource record names</p>
</li>
<li>
<p>allows names up to 255 bytes plus a terminating zero byte</p>
</li>
<li>
<p>allows name compression in rdata for SRV and other record types</p>
</li>
<li>
<p>allows larger UDP packets</p>
</li>
<li>
<p>allows more than one question in a query message</p>
</li>
<li>
<p>defines consistent results for qtype "ANY" and qclass "ANY" queries</p>
</li>
<li>
<p>uses the Answer Section of a query to list Known Answers</p>
</li>
<li>
<p>uses the TC bit in a query to indicate additional Known Answers</p>
</li>
<li>
<p>uses the Authority Section of a query for probe tiebreaking</p>
</li>
<li>
<p>ignores the Query ID field (except for generating legacy responses)</p>
</li>
<li>
<p>doesn&#8217;t require the question to be repeated in the response message</p>
</li>
<li>
<p>uses unsolicited responses to announce new records</p>
</li>
<li>
<p>uses NSEC records to signal nonexistence of records</p>
</li>
<li>
<p>defines a unicast-response bit in the rrclass of query questions</p>
</li>
<li>
<p>defines a cache-flush bit in the rrclass of response records</p>
</li>
<li>
<p>uses DNS RR TTL 0 to indicate that a record has been deleted</p>
</li>
<li>
<p>recommends AAAA records in the additional section when responding
to rrtype "A" queries, and vice versa</p>
</li>
<li>
<p>monitors queries to perform Duplicate Question Suppression</p>
</li>
<li>
<p>monitors responses to perform Duplicate Answer Suppression&#8230;&#8203;</p>
</li>
<li>
<p>&#8230;&#8203; and Ongoing Conflict Detection</p>
</li>
<li>
<p>&#8230;&#8203; and Opportunistic Caching</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ipv6_considerations">20. IPv6 Considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An IPv4-only host and an IPv6-only host behave as "ships that pass in
the night".  Even if they are on the same Ethernet, neither is aware
of the other&#8217;s traffic.  For this reason, each physical link may have
<strong>two</strong> unrelated ".local." zones, one for IPv4 and one for IPv6.
Since for practical purposes, a group of IPv4-only hosts and a group
of IPv6-only hosts on the same Ethernet act as if they were on two
entirely separate Ethernet segments, it is unsurprising that their
use of the ".local." zone should occur exactly as it would if they
really were on two entirely separate Ethernet segments.</p>
</div>
<div class="paragraph">
<p>A dual-stack (v4/v6) host can participate in both ".local." zones,
and should register its name(s) and perform its lookups both using
IPv4 and IPv6.  This enables it to reach, and be reached by, both
IPv4-only and IPv6-only hosts.  In effect, this acts like a
multihomed host, with one connection to the logical "IPv4 Ethernet
segment", and a connection to the logical "IPv6 Ethernet segment".
When such a host generates NSEC records, if it is using the same host
name for its IPv4 addresses and its IPv6 addresses on that network
interface, its NSEC records should indicate that the host name has
both A and AAAA records.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_security_considerations">21. Security Considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The algorithm for detecting and resolving name conflicts is, by its
very nature, an algorithm that assumes cooperating participants.  Its
purpose is to allow a group of hosts to arrive at a mutually disjoint
set of host names and other DNS resource record names, in the absence
of any central authority to coordinate this or mediate disputes.  In
the absence of any higher authority to resolve disputes, the only
alternative is that the participants must work together cooperatively
to arrive at a resolution.</p>
</div>
<div class="paragraph">
<p>In an environment where the participants are mutually antagonistic
and unwilling to cooperate, other mechanisms are appropriate, like
manually configured DNS.</p>
</div>
<div class="paragraph">
<p>In an environment where there is a group of cooperating participants,
but clients cannot be sure that there are no antagonistic hosts on
the same physical link, the cooperating participants need to use
IPsec signatures and/or DNSSEC [<a href="#ref_RFC4033">RFC4033</a>] signatures so that they can
distinguish Multicast DNS messages from trusted participants (which
they process as usual) from Multicast DNS messages from untrusted
participants (which they silently discard).</p>
</div>
<div class="paragraph">
<p>If DNS queries for <strong>global</strong> DNS names are sent to the mDNS multicast
address (during network outages which disrupt communication with the
greater Internet) it is <strong>especially</strong> important to use DNSSEC, because
the user may have the impression that he or she is communicating with
some authentic host, when in fact he or she is really communicating
with some local host that is merely masquerading as that name.  This
is less critical for names ending with ".local.", because the user
should be aware that those names have only local significance and no
global authority is implied.</p>
</div>
<div class="paragraph">
<p>Most computer users neglect to type the trailing dot at the end of a
fully qualified domain name, making it a relative domain name (e.g.,
"www.example.com").  In the event of network outage, attempts to
positively resolve the name as entered will fail, resulting in
application of the search list, including ".local.", if present.  A
malicious host could masquerade as "www.example.com." by answering
the resulting Multicast DNS query for "www.example.com.local.".  To
avoid this, a host MUST NOT append the search suffix ".local.", if
present, to any relative (partially qualified) host name containing
two or more labels.  Appending ".local." to single-label relative
host names is acceptable, since the user should have no expectation
that a single-label host name will resolve as is.  However, users who
have both "example.com" and "local" in their search lists should be
aware that if they type "www" into their web browser, it may not be
immediately clear to them whether the page that appears is
"www.example.com" or "www.local".</p>
</div>
<div class="paragraph">
<p>Multicast DNS uses UDP port 5353.  On operating systems where only
privileged processes are allowed to use ports below 1024, no such
privilege is required to use port 5353.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_iana_considerations">22. IANA Considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>IANA has allocated the UDP port 5353 for the Multicast DNS protocol
described in this document [<a href="#ref_SN">SN</a>].</p>
</div>
<div class="paragraph">
<p>IANA has allocated the IPv4 link-local multicast address 224.0.0.251
for the use described in this document [<a href="#ref_MC4">MC4</a>].</p>
</div>
<div class="paragraph">
<p>IANA has allocated the IPv6 multicast address set FF0X::FB (where "X"
indicates any hexadecimal digit from '1' to 'F') for the use
described in this document [<a href="#ref_MC6">MC6</a>].  Only address FF02::FB (link-local
scope) is currently in use by deployed software, but it is possible
that in the future implementers may experiment with Multicast DNS
using larger-scoped addresses, such as FF05::FB (site-local scope)
[<a href="#ref_RFC4291">RFC4291</a>].</p>
</div>
<div class="paragraph">
<p>IANA has implemented the following DNS records:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>MDNS.MCAST.NET.            IN  A    224.0.0.251
251.0.0.224.IN-ADDR.ARPA.  IN  PTR  MDNS.MCAST.NET.</pre>
</div>
</div>
<div class="paragraph">
<p>Entries for the AAAA and corresponding PTR records have not been made
as there is not yet an RFC providing direction for the management of
the IP6.ARPA domain relating to the IPv6 multicast address space.</p>
</div>
<div class="paragraph">
<p>The reuse of the top bit of the rrclass field in the Question and
Resource Record Sections means that Multicast DNS can only carry DNS
records with classes in the range 0-32767.  Classes in the range
32768 to 65535 are incompatible with Multicast DNS.  IANA has noted
this fact, and if IANA receives a request to allocate a DNS class
value above 32767, IANA will make sure the requester is aware of this
implication before proceeding.  This does not mean that allocations
of DNS class values above 32767 should be denied, only that they
should not be allowed until the requester has indicated that they are
aware of how this allocation will interact with Multicast DNS.
However, to date, only three DNS classes have been assigned by IANA
(1, 3, and 4), and only one (1, "Internet") is actually in widespread
use, so this issue is likely to remain a purely theoretical one.</p>
</div>
<div class="paragraph">
<p>IANA has recorded the list of domains below as being Special-Use
Domain Names [<a href="#ref_RFC6761">RFC6761</a>]:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.local.
.254.169.in-addr.arpa.
.8.e.f.ip6.arpa.
.9.e.f.ip6.arpa.
.a.e.f.ip6.arpa.
.b.e.f.ip6.arpa.</pre>
</div>
</div>
<div class="sect2">
<h3 id="_domain_name_reservation_considerations">22.1. Domain Name Reservation Considerations</h3>
<div class="paragraph">
<p>The six domains listed above, and any names falling within those
domains (e.g., "MyPrinter.local.", "34.12.254.169.in-addr.arpa.",
"Ink-Jet._pdl-datastream._tcp.local.") are special [<a href="#ref_RFC6761">RFC6761</a>] in the
following ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Users may use these names as they would other DNS names,
entering them anywhere that they would otherwise enter a
conventional DNS name, or a dotted decimal IPv4 address, or a
literal IPv6 address.</p>
<div class="paragraph">
<p>Since there is no central authority responsible for assigning
dot-local names, and all devices on the local network are
equally entitled to claim any dot-local name, users SHOULD be
aware of this and SHOULD exercise appropriate caution.  In an
untrusted or unfamiliar network environment, users SHOULD be
aware that using a name like "www.local" may not actually
connect them to the web site they expected, and could easily
connect them to a different web page, or even a fake or spoof
of their intended web site, designed to trick them into
revealing confidential information.  As always with networking,
end-to-end cryptographic security can be a useful tool.  For
example, when connecting with ssh, the ssh host key
verification process will inform the user if it detects that
the identity of the entity they are communicating with has
changed since the last time they connected to that name.</p>
</div>
</li>
<li>
<p>Application software may use these names as they would other
similar DNS names, and is not required to recognize the names
and treat them specially.  Due to the relative ease of spoofing
dot-local names, end-to-end cryptographic security remains
important when communicating across a local network, just as it
is when communicating across the global Internet.</p>
</li>
<li>
<p>Name resolution APIs and libraries SHOULD recognize these names
as special and SHOULD NOT send queries for these names to their
configured (unicast) caching DNS server(s).  This is to avoid
unnecessary load on the root name servers and other name
servers, caused by queries for which those name servers do not
have useful non-negative answers to give, and will not ever
have useful non-negative answers to give.</p>
</li>
<li>
<p>Caching DNS servers SHOULD recognize these names as special and
SHOULD NOT attempt to look up NS records for them, or otherwise
query authoritative DNS servers in an attempt to resolve these
names.  Instead, caching DNS servers SHOULD generate immediate
NXDOMAIN responses for all such queries they may receive (from
misbehaving name resolver libraries).  This is to avoid
unnecessary load on the root name servers and other name
servers.</p>
</li>
<li>
<p>Authoritative DNS servers SHOULD NOT by default be configurable
to answer queries for these names, and, like caching DNS
servers, SHOULD generate immediate NXDOMAIN responses for all
such queries they may receive.  DNS server software MAY provide
a configuration option to override this default, for testing
purposes or other specialized uses.</p>
</li>
<li>
<p>DNS server operators SHOULD NOT attempt to configure
authoritative DNS servers to act as authoritative for any of
these names.  Configuring an authoritative DNS server to act as
authoritative for any of these names may not, in many cases,
yield the expected result.  Since name resolver libraries and
caching DNS servers SHOULD NOT send queries for those names
(see 3 and 4 above), such queries SHOULD be suppressed before
they even reach the authoritative DNS server in question, and
consequently it will not even get an opportunity to answer
them.</p>
</li>
<li>
<p>DNS Registrars MUST NOT allow any of these names to be
registered in the normal way to any person or entity.  These
names are reserved protocol identifiers with special meaning
and fall outside the set of names available for allocation by
registrars.  Attempting to allocate one of these names as if it
were a normal domain name will probably not work as desired,
for reasons 3, 4, and 6 above.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_acknowledgments">22.2. Acknowledgments</h3>
<div class="paragraph">
<p>The concepts described in this document have been explored,
developed, and implemented with help from Ran Atkinson, Richard
Brown, Freek Dijkstra, Erik Guttman, Kyle McKay, Pasi Sarolahti,
Pekka Savola, Robby Simpson, Mark Townsley, Paul Vixie, Bill
Woodcock, and others.  Special thanks go to Bob Bradley, Josh
Graessley, Scott Herscher, Rory McGuire, Roger Pantos, and Kiren
Sekar for their significant contributions.  Special thanks also to
Kerry Lynn for converting the document to xml2rfc form in May 2010,
and to Area Director Ralph Droms for shepherding the document through
its final steps.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references">23. References</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_normative_references">23.1. Normative References</h3>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a id="ref_MC4"></a> [MC4] 
</td>
<td class="hdlist2">
<p>IANA, "IPv4 Multicast Address Space Registry",
<a href="http://www.iana.org/assignments/multicast-addresses/" class="bare">http://www.iana.org/assignments/multicast-addresses/</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_MC6"></a> [MC6] 
</td>
<td class="hdlist2">
<p>IANA, "IPv6 Multicast Address Space Registry",
&lt;<a href="http://www.iana.org/assignments/" class="bare">http://www.iana.org/assignments/</a>
ipv6-multicast-addresses/&gt;.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC0020"></a> [RFC0020] 
</td>
<td class="hdlist2">
<p>Cerf, V., "ASCII format for network interchange", RFC 20,
October 1969.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC1034"></a> [RFC1034] 
</td>
<td class="hdlist2">
<p>Mockapetris, P., "Domain names - concepts and facilities",
STD 13, RFC 1034, November 1987.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC1035"></a> [RFC1035] 
</td>
<td class="hdlist2">
<p>Mockapetris, P., "Domain names - implementation and
specification", STD 13, RFC 1035, November 1987.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2119"></a> [RFC2119] 
</td>
<td class="hdlist2">
<p>Bradner, S., "Key words for use in RFCs to Indicate
Requirement Levels", BCP 14, RFC 2119, March 1997.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC3629"></a> [RFC3629] 
</td>
<td class="hdlist2">
<p>Yergeau, F., "UTF-8, a transformation format of ISO
10646", STD 63, RFC 3629, November 2003.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC4034"></a> [RFC4034] 
</td>
<td class="hdlist2">
<p>Arends, R., Austein, R., Larson, M., Massey, D., and S.
Rose, "Resource Records for the DNS Security Extensions",
RFC 4034, March 2005.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC5198"></a> [RFC5198] 
</td>
<td class="hdlist2">
<p>Klensin, J. and M. Padlipsky, "Unicode Format for Network
Interchange", RFC 5198, March 2008.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC6195"></a> [RFC6195] 
</td>
<td class="hdlist2">
<p>Eastlake 3rd, D., "Domain Name System (DNS) IANA
Considerations", BCP 42, RFC 6195, March 2011.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC6761"></a> [RFC6761] 
</td>
<td class="hdlist2">
<p>Cheshire, S. and M. Krochmal, "Special-Use Domain Names",
RFC 6761, February 2013.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_SN"></a> [SN] 
</td>
<td class="hdlist2">
<p>IANA, "Service Name and Transport Protocol Port Number
Registry", &lt;<a href="http://www.iana.org/assignments/" class="bare">http://www.iana.org/assignments/</a>
service-names-port-numbers/&gt;.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_informative_references">23.2. Informative References</h3>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a id="ref_B4W"></a>   [B4W]  
</td>
<td class="hdlist2">
<p>"Bonjour for Windows",
<a href="http://en.wikipedia.org/wiki/Bonjour_(software)" class="bare">http://en.wikipedia.org/wiki/Bonjour_(software)</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_BJ"></a>  [BJ] 
</td>
<td class="hdlist2">
<p>Apple Bonjour Open Source Software,
<a href="http://developer.apple.com/bonjour/" class="bare">http://developer.apple.com/bonjour/</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_IEEE.802.3"></a>   [IEEE.802.3] 
</td>
<td class="hdlist2">
<p>"Information technology - Telecommunications and
information exchange between systems - Local and
metropolitan area networks - Specific requirements - Part
3: Carrier Sense Multiple Access with Collision Detection
(CMSA/CD) Access Method and Physical Layer
Specifications", IEEE Std 802.3-2008, December 2008,
<a href="http://standards.ieee.org/getieee802/802.3.html" class="bare">http://standards.ieee.org/getieee802/802.3.html</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_IEEE.802.11"></a>   [IEEE.802.11] 
</td>
<td class="hdlist2">
<p>"Information technology - Telecommunications and
information exchange between systems - Local and
metropolitan area networks - Specific requirements - Part
11: Wireless LAN Medium Access Control (MAC) and Physical
Layer (PHY) Specifications", IEEE Std 802.11-2007, June
2007, <a href="http://standards.ieee.org/getieee802/802.11.html" class="bare">http://standards.ieee.org/getieee802/802.11.html</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_Jumbo"></a>   [Jumbo] 
</td>
<td class="hdlist2">
<p>"Ethernet Jumbo Frames", November 2009,
&lt;<a href="http://www.ethernetalliance.org/library/whitepaper/" class="bare">http://www.ethernetalliance.org/library/whitepaper/</a>
ethernet-jumbo-frames/&gt;.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_NIAS"></a>   [NIAS]  
</td>
<td class="hdlist2">
<p>Cheshire, S. "Discovering Named Instances of Abstract
Services using DNS", Work in Progress, July 2001.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_NSD"></a>   [NSD]  
</td>
<td class="hdlist2">
<p>"NsdManager | Android Developer", June 2012,
&lt;<a href="http://developer.android.com/reference/" class="bare">http://developer.android.com/reference/</a>
android/net/nsd/NsdManager.html&gt;.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2052"></a>  [RFC2052] 
</td>
<td class="hdlist2">
<p>Gulbrandsen, A. and P. Vixie, "A DNS RR for specifying the
location of services (DNS SRV)", RFC 2052, October 1996.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2132"></a>   [RFC2132] 
</td>
<td class="hdlist2">
<p>Alexander, S. and R. Droms, "DHCP Options and BOOTP Vendor
Extensions", RFC 2132, March 1997.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2136"></a>   [RFC2136] 
</td>
<td class="hdlist2">
<p>Vixie, P., Ed., Thomson, S., Rekhter, Y., and J. Bound,
"Dynamic Updates in the Domain Name System (DNS UPDATE)",
RFC 2136, April 1997.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2181"></a>   [RFC2181] 
</td>
<td class="hdlist2">
<p>Elz, R. and R. Bush, "Clarifications to the DNS
Specification", RFC 2181, July 1997.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2535"></a>   [RFC2535] 
</td>
<td class="hdlist2">
<p>Eastlake 3rd, D., "Domain Name System Security
Extensions", RFC 2535, March 1999.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2671"></a>   [RFC2671] 
</td>
<td class="hdlist2">
<p>Vixie, P., "Extension Mechanisms for DNS (EDNS0)", RFC
2671, August 1999.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2845"></a>   [RFC2845] 
</td>
<td class="hdlist2">
<p>Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B.
Wellington, "Secret Key Transaction Authentication for DNS
(TSIG)", RFC 2845, May 2000.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2930"></a>   [RFC2930] 
</td>
<td class="hdlist2">
<p>Eastlake 3rd, D., "Secret Key Establishment for DNS (TKEY
RR)", RFC 2930, September 2000.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC2931"></a>   [RFC2931] 
</td>
<td class="hdlist2">
<p>Eastlake 3rd, D., "DNS Request and Transaction Signatures
( SIG(0)s )", RFC 2931, September 2000.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC3007"></a>   [RFC3007] 
</td>
<td class="hdlist2">
<p>Wellington, B., "Secure Domain Name System (DNS) Dynamic
Update", RFC 3007, November 2000.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="refRFC3492"></a>   [RFC3492] 
</td>
<td class="hdlist2">
<p>Costello, A., "Punycode: A Bootstring encoding of Unicode
for Internationalized Domain Names in Applications
(IDNA)", RFC 3492, March 2003.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC3927"></a>   [RFC3927] 
</td>
<td class="hdlist2">
<p>Cheshire, S., Aboba, B., and E. Guttman, "Dynamic
Configuration of IPv4 Link-Local Addresses", RFC 3927, May
2005.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC4033"></a>   [RFC4033] 
</td>
<td class="hdlist2">
<p>Arends, R., Austein, R., Larson, M., Massey, D., and S.
Rose, "DNS Security Introduction and Requirements", RFC
4033, March 2005.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC4291"></a>   [RFC4291] 
</td>
<td class="hdlist2">
<p>Hinden, R. and S. Deering, "IP Version 6 Addressing
Architecture", RFC 4291, February 2006.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC4795"></a>   [RFC4795] 
</td>
<td class="hdlist2">
<p>Aboba, B., Thaler, D., and L. Esibov, "Link-local
Multicast Name Resolution (LLMNR)", RFC 4795, January
2007.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC4861"></a>   [RFC4861] 
</td>
<td class="hdlist2">
<p>Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
"Neighbor Discovery for IP version 6 (IPv6)", RFC 4861,
September 2007.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC4862"></a>   [RFC4862] 
</td>
<td class="hdlist2">
<p>Thomson, S., Narten, T., and T. Jinmei, "IPv6 Stateless
Address Autoconfiguration", RFC 4862, September 2007.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC5226"></a>   [RFC5226] 
</td>
<td class="hdlist2">
<p>Narten, T. and H. Alvestrand, "Guidelines for Writing an
IANA Considerations Section in RFCs", BCP 26, RFC 5226,
May 2008.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC5890"></a>   [RFC5890] 
</td>
<td class="hdlist2">
<p>Klensin, J., "Internationalized Domain Names for
Applications (IDNA): Definitions and Document Framework",
RFC 5890, August 2010.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC6281"></a>   [RFC6281] 
</td>
<td class="hdlist2">
<p>Cheshire, S., Zhu, Z., Wakikawa, R., and L. Zhang,
"Understanding Apple&#8217;s Back to My Mac (BTMM) Service", RFC
6281, June 2011.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC6760"></a>   [RFC6760] 
</td>
<td class="hdlist2">
<p>Cheshire, S. and M. Krochmal, "Requirements for a Protocol
to Replace the AppleTalk Name Binding Protocol (NBP)", RFC
6760, February 2013.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_RFC6763"></a>   [RFC6763] 
</td>
<td class="hdlist2">
<p>Cheshire, S. and M. Krochmal, "DNS-Based Service
Discovery", RFC 6763, February 2013.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a id="ref_Zeroconf"></a>   [Zeroconf] 
</td>
<td class="hdlist2">
<p>Cheshire, S. and D. Steinberg, "Zero Configuration
Networking: The Definitive Guide", O&#8217;Reilly Media, Inc.,
ISBN 0-596-10100-7, December 2005.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_A">Appendix A: Design Rationale for Choice of UDP Port Number</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Arguments were made for and against using UDP port 53, the standard
Unicast DNS port.  Some of the arguments are given below.  The
arguments for using a different port were greater in number and more
compelling, so that option was ultimately selected.  The UDP port
"5353" was selected for its mnemonic similarity to "53".</p>
</div>
<div class="paragraph">
<p>Arguments for using UDP port 53:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is "just DNS", so it should be the same port.</p>
</li>
<li>
<p>There is less work to be done updating old resolver libraries to do
simple Multicast DNS queries.  Only the destination address need be
changed.  In some cases, this can be achieved without any code
changes, just by adding the address 224.0.0.251 to a configuration
file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Arguments for using a different port (UDP port 5353):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This is not "just DNS".  This is a DNS-like protocol, but
different.</p>
</li>
<li>
<p>Changing resolver library code to use a different port number is
not hard.  In some cases, this can be achieved without any code
changes, just by adding the address 224.0.0.251:5353 to a
configuration file.</p>
</li>
<li>
<p>Using the same port number makes it hard to run a Multicast DNS
responder and a conventional Unicast DNS server on the same
machine.  If a conventional Unicast DNS server wishes to implement
Multicast DNS as well, it can still do that, by opening two
sockets.  Having two different port numbers allows this
flexibility.</p>
</li>
<li>
<p>Some VPN software hijacks all outgoing traffic to port 53 and
redirects it to a special DNS server set up to serve those VPN
clients while they are connected to the corporate network.  It is
questionable whether this is the right thing to do, but it is
common, and redirecting link-local multicast DNS packets to a
remote server rarely produces any useful results.  It does mean,
for example, that a user of such VPN software becomes unable to
access their local network printer sitting on their desk right next
to their computer.  Using a different UDP port helps avoid this
particular problem.</p>
</li>
<li>
<p>On many operating systems, unprivileged software may not send or
receive packets on low-numbered ports.  This means that any
software sending or receiving Multicast DNS packets on port 53
would have to run as "root", which is an undesirable security risk.
Using a higher-numbered UDP port avoids this restriction.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_B">Appendix B: Design Rationale for Not Using Hashed Multicast Addresses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some discovery protocols use a range of multicast addresses, and
determine the address to be used by a hash function of the name being
sought.  Queries are sent via multicast to the address as indicated
by the hash function, and responses are returned to the querier via
unicast.  Particularly in IPv6, where multicast addresses are
extremely plentiful, this approach is frequently advocated.  For
example, IPv6 Neighbor Discovery [<a href="#ref_RFC4861">RFC4861</a>] sends Neighbor
Solicitation messages to the "solicited-node multicast address",
which is computed as a function of the solicited IPv6 address.</p>
</div>
<div class="paragraph">
<p>There are some disadvantages to using hashed multicast addresses like
this in a service discovery protocol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a host has a large number of records with different names, the
host may have to join a large number of multicast groups.  Each
time a host joins or leaves a multicast group, this results in
Internet Group Management Protocol (IGMP) or Multicast Listener
Discovery (MLD) traffic on the network announcing this fact.
Joining a large number of multicast groups can place undue burden
on the Ethernet hardware, which typically supports a limited number
of multicast addresses efficiently.  When this number is exceeded,
the Ethernet hardware may have to resort to receiving all
multicasts and passing them up to the host networking code for
filtering in software, thereby defeating much of the point of using
a multicast address range in the first place.  Finally, many IPv6
stacks have a fixed limit IPV6_MAX_MEMBERSHIPS, and the code simply
fails with an error if a client attempts to exceed this limit.
Common values for IPV6_MAX_MEMBERSHIPS are 20 or 31.</p>
</li>
<li>
<p>Multiple questions cannot be placed in one packet if they don&#8217;t all
hash to the same multicast address.</p>
</li>
<li>
<p>Duplicate Question Suppression doesn&#8217;t work if queriers are not
seeing each other&#8217;s queries.</p>
</li>
<li>
<p>Duplicate Answer Suppression doesn&#8217;t work if responders are not
seeing each other&#8217;s responses.</p>
</li>
<li>
<p>Opportunistic Caching doesn&#8217;t work.</p>
</li>
<li>
<p>Ongoing Conflict Detection doesn&#8217;t work.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_C">Appendix C: Design Rationale for Maximum Multicast DNS Name Length</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multicast DNS names may be up to 255 bytes long (in the on-the-wire
message format), not counting the terminating zero byte at the end.</p>
</div>
<div class="paragraph">
<p>"Domain Names - Implementation and Specification" [<a href="#ref_RFC1035">RFC1035</a>] says:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Various objects and parameters in the DNS have size limits.  They
are listed below.  Some could be easily changed, others are more
fundamental.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> labels          63 octets or less

 names           255 octets or less

 ...</pre>
</div>
</div>
<div class="paragraph">
<p>the total length of a domain name (i.e., label octets and label
length octets) is restricted to 255 octets or less.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This text does not state whether this 255-byte limit includes the
terminating zero at the end of every name.</p>
</div>
<div class="paragraph">
<p>Several factors lead us to conclude that the 255-byte limit does
<strong>not</strong> include the terminating zero:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is common in software engineering to have size limits that are a
power of two, or a multiple of a power of two, for efficiency.  For
example, an integer on a modern processor is typically 2, 4, or 8
bytes, not 3 or 5 bytes.  The number 255 is not a power of two, nor
is it to most people a particularly noteworthy number.  It is
noteworthy to computer scientists for only one reason&#8201;&#8212;&#8201;because it
is exactly one <strong>less</strong> than a power of two.  When a size limit is
exactly one less than a power of two, that suggests strongly that
the one extra byte is being reserved for some specific reason&#8201;&#8212;&#8201;in
this case reserved, perhaps, to leave room for a terminating zero
at the end.</p>
</li>
<li>
<p>In the case of DNS label lengths, the stated limit is 63 bytes.  As
with the total name length, this limit is exactly one less than a
power of two.  This label length limit also excludes the label
length byte at the start of every label.  Including that extra
byte, a 63-byte label takes 64 bytes of space in memory or in a DNS
message.</p>
</li>
<li>
<p>It is common in software engineering for the semantic "length" of
an object to be one less than the number of bytes it takes to store
that object.  For example, in C, strlen("foo") is 3, but
sizeof("foo") (which includes the terminating zero byte at the end)
is 4.</p>
</li>
<li>
<p>The text describing the total length of a domain name mentions
explicitly that label length and data octets are included, but does
not mention the terminating zero at the end.  The zero byte at the
end of a domain name is not a label length.  Indeed, the value zero
is chosen as the terminating marker precisely because it is not a
legal length byte value&#8201;&#8212;&#8201;DNS prohibits empty labels.  For
example, a name like "bad..name." is not a valid domain name
because it contains a zero-length label in the middle, which cannot
be expressed in a DNS message, because software parsing the message
would misinterpret a zero label-length byte as being a zero "end of
name" marker instead.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, "Clarifications to the DNS Specification" [<a href="#ref_RFC2181">RFC2181</a>] offers
additional confirmation that, in the context of DNS specifications,
the stated "length" of a domain name does not include the terminating
zero byte at the end.  That document refers to the root name, which
is typically written as "." and is represented in a DNS message by a
single lone zero byte (i.e., zero bytes of data plus a terminating
zero), as the "zero length full name":</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>The zero length full name is defined as representing the root of
the DNS tree, and is typically written and displayed as ".".</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This wording supports the interpretation that, in a DNS context, when
talking about lengths of names, the terminating zero byte at the end
is not counted.  If the root name (".") is considered to be zero
length, then to be consistent, the length (for example) of "org" has
to be 4 and the length of "ietf.org" has to be 9, as shown below:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                                               ------
                                              | 0x00 |   length = 0
                                               ------

                          ------------------   ------
                         | 0x03 | o | r | g | | 0x00 |   length = 4
                          ------------------   ------

   -----------------------------------------   ------
  | 0x04 | i | e | t | f | 0x03 | o | r | g | | 0x00 |   length = 9
   -----------------------------------------   ------</pre>
</div>
</div>
<div class="paragraph">
<p>This means that the maximum length of a domain name, as represented
in a Multicast DNS message, up to but not including the final
terminating zero, must not exceed 255 bytes.</p>
</div>
<div class="paragraph">
<p>However, many Unicast DNS implementers have read these RFCs
differently, and argue that the 255-byte limit does include the
terminating zero, and that the "Clarifications to the DNS
Specification" [<a href="#ref_RFC2181">RFC2181</a>] statement that "." is the "zero length full
name" was simply a mistake.</p>
</div>
<div class="paragraph">
<p>Hence, implementers should be aware that other Unicast DNS
implementations may limit the maximum domain name to 254 bytes plus a
terminating zero, depending on how that implementer interpreted the
DNS specifications.</p>
</div>
<div class="paragraph">
<p>Compliant Multicast DNS implementations MUST support names up to 255
bytes plus a terminating zero, i.e., 256 bytes total.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_D">Appendix D: Benefits of Multicast Responses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some people have argued that sending responses via multicast is
inefficient on the network.  In fact, using multicast responses can
result in a net lowering of overall multicast traffic for a variety
of reasons, and provides other benefits too:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Opportunistic Caching.  One multicast response can update the
caches on all machines on the network.  If another machine later
wants to issue the same query, and it already has the answer in its
cache, it may not need to even transmit that multicast query on the
network at all.</p>
</li>
<li>
<p>Duplicate Query Suppression.  When more than one machine has the
same ongoing long-lived query running, every machine does not have
to transmit its own independent query.  When one machine transmits
a query, all the other hosts see the answers, so they can suppress
their own queries.</p>
</li>
<li>
<p>Passive Observation Of Failures (POOF).  When a host sees a
multicast query, but does not see the corresponding multicast
response, it can use this information to promptly delete stale data
from its cache.  To achieve the same level of user-interface
quality and responsiveness without multicast responses would
require lower cache lifetimes and more frequent network polling,
resulting in a higher packet rate.</p>
</li>
<li>
<p>Passive Conflict Detection.  Just because a name has been
previously verified to be unique does not guarantee it will
continue to be so indefinitely.  By allowing all Multicast DNS
responders to constantly monitor their peers' responses, conflicts
arising out of network topology changes can be promptly detected
and resolved.  If responses were not sent via multicast, some other
conflict detection mechanism would be needed, imposing its own
additional burden on the network.</p>
</li>
<li>
<p>Use on devices with constrained memory resources: When using
delayed responses to reduce network collisions, responders need to
maintain a list recording to whom each answer should be sent.  The
option of multicast responses allows responders with limited
storage, which cannot store an arbitrarily long list of response
addresses, to choose to fail-over to a single multicast response in
place of multiple unicast responses, when appropriate.</p>
</li>
<li>
<p>Overlayed Subnets.  In the case of overlayed subnets, multicast
responses allow a receiver to know with certainty that a response
originated on the local link, even when its source address may
apparently suggest otherwise.</p>
</li>
<li>
<p>Robustness in the face of misconfiguration: Link-local multicast
transcends virtually every conceivable network misconfiguration.
Even if you have a collection of devices where every device&#8217;s IP
address, subnet mask, default gateway, and DNS server address are
all wrong, packets sent by any of those devices addressed to a
link-local multicast destination address will still be delivered to
all peers on the local link.  This can be extremely helpful when
diagnosing and rectifying network problems, since it facilitates a
direct communication channel between client and server that works
without reliance on ARP, IP routing tables, etc.  Being able to
discover what IP address a device has (or thinks it has) is
frequently a very valuable first step in diagnosing why it is
unable to communicate on the local network.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_E">Appendix E: Design Rationale for Encoding Negative Responses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Alternative methods of asserting nonexistence were considered, such
as using an NXDOMAIN response, or emitting a resource record with
zero-length rdata.</p>
</div>
<div class="paragraph">
<p>Using an NXDOMAIN response does not work well with Multicast DNS.  A
Unicast DNS NXDOMAIN response applies to the entire message, but for
efficiency Multicast DNS allows (and encourages) multiple responses
in a single message.  If the error code in the header were NXDOMAIN,
it would not be clear to which name(s) that error code applied.</p>
</div>
<div class="paragraph">
<p>Asserting nonexistence by emitting a resource record with zero-length
rdata would mean that there would be no way to differentiate between
a record that doesn&#8217;t exist, and a record that does exist, with zero-
length rdata.  By analogy, most file systems today allow empty files,
so a file that exists with zero bytes of data is not considered
equivalent to a filename that does not exist.</p>
</div>
<div class="paragraph">
<p>A benefit of asserting nonexistence through NSEC records instead of
through NXDOMAIN responses is that NSEC records can be added to the
Additional Section of a DNS response to offer additional information
beyond what the querier explicitly requested.  For example, in
response to an SRV query, a responder should include A record(s)
giving its IPv4 addresses in the Additional Section, and an NSEC
record indicating which other types it does or does not have for this
name.  If the responder is running on a host that does not support
IPv6 (or does support IPv6 but currently has no IPv6 address on that
interface) then this NSEC record in the Additional Section will
indicate this absence of AAAA records.  In effect, the responder is
saying, "Here&#8217;s my SRV record, and here are my IPv4 addresses, and
no, I don&#8217;t have any IPv6 addresses, so don&#8217;t waste your time
asking".  Without this information in the Additional Section, it
would take the querier an additional round-trip to perform an
additional query to ascertain that the target host has no AAAA
records.  (Arguably Unicast DNS could also benefit from this ability
to express nonexistence in the Additional Section, but that is
outside the scope of this document.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_F">Appendix F: Use of UTF-8</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After many years of debate, as a result of the perceived need to
accommodate certain DNS implementations that apparently couldn&#8217;t
handle any character that&#8217;s not a letter, digit, or hyphen (and
apparently never would be updated to remedy this limitation), the
Unicast DNS community settled on an extremely baroque encoding called
"Punycode" [<a href="#ref_RFC3492">[ref_RFC3492]</a>].  Punycode is a remarkably ingenious encoding
solution, but it is complicated, hard to understand, and hard to
implement, using sophisticated techniques including insertion unsort
coding, generalized variable-length integers, and bias adaptation.
The resulting encoding is remarkably compact given the constraints,
but it&#8217;s still not as good as simple straightforward UTF-8, and it&#8217;s
hard even to predict whether a given input string will encode to a
Punycode string that fits within DNS&#8217;s 63-byte limit, except by
simply trying the encoding and seeing whether it fits.  Indeed, the
encoded size depends not only on the input characters, but on the
order they appear, so the same set of characters may or may not
encode to a legal Punycode string that fits within DNS&#8217;s 63-byte
limit, depending on the order the characters appear.  This is
extremely hard to present in a user interface that explains to users
why one name is allowed, but another name containing the exact same
characters is not.  Neither Punycode nor any other of the "ASCII-
Compatible Encodings" [<a href="#ref_RFC5890">RFC5890</a>] proposed for Unicast DNS may be used
in Multicast DNS messages.  Any text being represented internally in
some other representation must be converted to canonical precomposed
UTF-8 before being placed in any Multicast DNS message.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_private_dns_namespaces">Appendix G: Private DNS Namespaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The special treatment of names ending in ".local." has been
implemented in Macintosh computers since the days of Mac OS 9, and
continues today in Mac OS X and iOS.  There are also implementations
for Microsoft Windows [<a href="#ref_B4W">B4W</a>], Linux, and other platforms.</p>
</div>
<div class="paragraph">
<p>Some network operators setting up private internal networks
("intranets") have used unregistered top-level domains, and some may
have used the ".local" top-level domain.  Using ".local" as a private
top-level domain conflicts with Multicast DNS and may cause problems
for users.  Clients can be configured to send both Multicast and
Unicast DNS queries in parallel for these names, and this does allow
names to be looked up both ways, but this results in additional
network traffic and additional delays in name resolution, as well as
potentially creating user confusion when it is not clear whether any
given result was received via link-local multicast from a peer on the
same link, or from the configured unicast name server.  Because of
this, we recommend against using ".local" as a private Unicast DNS
top-level domain.  We do not recommend use of unregistered top-level
domains at all, but should network operators decide to do this, the
following top-level domains have been used on private internal
networks without the problems caused by trying to reuse ".local." for
this purpose:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.intranet.
.internal.
.private.
.corp.
.home.
.lan.</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deployment_history">Appendix H: Deployment History</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In July 1997, in an email to the <a href="mailto:net-thinkers@thumper.vmeng.com">net-thinkers@thumper.vmeng.com</a>
mailing list, Stuart Cheshire first proposed the idea of running the
AppleTalk Name Binding Protocol [<a href="#ref_RFC6760">RFC6760</a>] over IP.  As a result of
this and related IETF discussions, the IETF Zeroconf working group
was chartered September 1999.  After various working group
discussions and other informal IETF discussions, several Internet-
Drafts were written that were loosely related to the general themes
of DNS and multicast, but did not address the service discovery
aspect of NBP.</p>
</div>
<div class="paragraph">
<p>In April 2000, Stuart Cheshire registered IPv4 multicast address
224.0.0.251 with IANA [<a href="#ref_MC4">MC4</a>] and began writing code to test and
develop the idea of performing NBP-like service discovery using
Multicast DNS, which was documented in a group of three Internet-
Drafts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>"Requirements for a Protocol to Replace the AppleTalk Name Binding
Protocol (NBP)" [<a href="#ref_RFC6760">RFC6760</a>] is an overview explaining the AppleTalk
Name Binding Protocol, because many in the IETF community had
little first-hand experience using AppleTalk, and confusion in the
IETF community about what AppleTalk NBP did was causing confusion
about what would be required in an IP-based replacement.</p>
</li>
<li>
<p>"Discovering Named Instances of Abstract Services using DNS" [<a href="#ref_NIAS">NIAS</a>]
proposed a way to perform NBP-like service discovery using DNS-
compatible names and record types.</p>
</li>
<li>
<p>"Multicast DNS" (this document) specifies a way to transport those
DNS-compatible queries and responses using IP multicast, for zero-
configuration environments where no conventional Unicast DNS server
was available.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In 2001, an update to Mac OS 9 added resolver library support for
host name lookup using Multicast DNS.  If the user typed a name such
as "MyPrinter.local." into any piece of networking software that used
the standard Mac OS 9 name lookup APIs, then those name lookup APIs
would recognize the name as a dot-local name and query for it by
sending simple one-shot Multicast DNS queries to 224.0.0.251:5353.
This enabled the user to, for example, enter the name
"MyPrinter.local." into their web browser in order to view a
printer&#8217;s status and configuration web page, or enter the name
"MyPrinter.local." into the printer setup utility to create a print
queue for printing documents on that printer.</p>
</div>
<div class="paragraph">
<p>Multicast DNS responder software, with full service discovery, first
began shipping to end users in volume with the launch of Mac OS X
10.2 "Jaguar" in August 2002, and network printer makers (who had
historically supported AppleTalk in their network printers and were
receptive to IP-based technologies that could offer them similar
ease-of-use) started adopting Multicast DNS shortly thereafter.</p>
</div>
<div class="paragraph">
<p>In September 2002, Apple released the source code for the
mDNSResponder daemon as Open Source under Apple&#8217;s standard Apple
Public Source License (APSL).</p>
</div>
<div class="paragraph">
<p>Multicast DNS responder software became available for Microsoft
Windows users in June 2004 with the launch of Apple&#8217;s "Rendezvous for
Windows" (now "Bonjour for Windows"), both in executable form (a
downloadable installer for end users) and as Open Source (one of the
supported platforms within Apple&#8217;s body of cross-platform code in the
publicly accessible mDNSResponder CVS source code repository) [<a href="#ref_BJ">BJ</a>].</p>
</div>
<div class="paragraph">
<p>In August 2006, Apple re-licensed the cross-platform mDNSResponder
source code under the Apache License, Version 2.0.</p>
</div>
<div class="paragraph">
<p>In addition to desktop and laptop computers running Mac OS X and
Microsoft Windows, Multicast DNS is now implemented in a wide range
of hardware devices, such as Apple&#8217;s "AirPort" wireless base
stations, iPhone and iPad, and in home gateways from other vendors,
network printers, network cameras, TiVo DVRs, etc.</p>
</div>
<div class="paragraph">
<p>The Open Source community has produced many independent
implementations of Multicast DNS, some in C like Apple&#8217;s
mDNSResponder daemon, and others in a variety of different languages
including Java, Python, Perl, and C#/Mono.</p>
</div>
<div class="paragraph">
<p>In January 2007, the IETF published the Informational RFC "Link-Local
Multicast Name Resolution (LLMNR)" [<a href="#ref_RFC4795">RFC4795</a>], which is substantially
similar to Multicast DNS, but incompatible in some small but
important ways.  In particular, the LLMNR design explicitly excluded
support for service discovery, which made it an unsuitable candidate
for a protocol to replace AppleTalk NBP [<a href="#ref_RFC6760">RFC6760</a>].</p>
</div>
<div class="paragraph">
<p>While the original focus of Multicast DNS and DNS-Based Service
Discovery was for zero-configuration environments without a
conventional Unicast DNS server, DNS-Based Service Discovery also
works using Unicast DNS servers, using DNS Update [<a href="#ref_RFC2136">RFC2136</a>] [<a href="#ref_RFC3007">RFC3007</a>]
to create service discovery records and standard DNS queries to query
for them.  Apple&#8217;s Back to My Mac service, launched with Mac OS X
10.5 "Leopard" in October 2007, uses DNS-Based Service Discovery over
Unicast DNS [<a href="#ref_RFC6281">RFC6281</a>].</p>
</div>
<div class="paragraph">
<p>In June 2012, Google&#8217;s Android operating system added native support
for DNS-SD and Multicast DNS with the android.net.nsd.NsdManager
class in Android 4.1 "Jelly Bean" (API Level 16) [<a href="#ref_NSD">NSD</a>].</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_authors_addresses">Authors' Addresses</h2>
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Stuart Cheshire<br>
Apple Inc.<br>
1 Infinite Loop<br>
Cupertino, CA  95014<br>
USA</p>
</div>
<div class="paragraph">
<p>Phone: +1 408 974 3207<br>
EMail: <a href="mailto:cheshire@apple.com">cheshire@apple.com</a></p>
</div>
<div class="paragraph">
<p>Marc Krochmal<br>
Apple Inc.<br>
1 Infinite Loop<br>
Cupertino, CA  95014<br>
USA</p>
</div>
<div class="paragraph">
<p>Phone: +1 408 974 4368<br>
EMail: <a href="mailto:marc@apple.com">marc@apple.com</a></p>
</div>
</div>
</div>
<hr>
<hr>
<table class="tableblock frame-none grid-all" style="width: 99%;">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">END OF THE RFC</p></td>
</tr>
</tbody>
</table>
<hr>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_errata">Errata</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_reported">Reported</h3>
<div class="sect3">
<h4 id="_4977">4977</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Errata ID: <a href="https://www.rfc-editor.org/errata/eid4977">4977</a><br>
Status: Reported<br>
Type: Technical<br>
Publication Format(s) : TEXT<br>
Reported By: Nathan Osman<br>
Date Reported: 2017-03-23<br></p>
</div>
<div class="paragraph">
<p>Section <a href="#_negative_responses">6.1</a> says:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The 'Next Domain Name' field contains the record's own name. <strong>When
used with name compression, this means that the 'Next Domain Name'
field always takes exactly two bytes in the message.</strong></pre>
</div>
</div>
<div class="paragraph">
<p>It should say:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The 'Next Domain Name' field contains the record's own name.</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Section 4.1.1 of RFC 4034 states:</p>
</div>
<div class="paragraph">
<p>"A sender MUST NOT use DNS name compression on the Next Domain Name
field when transmitting an NSEC RR."</p>
</div>
<div class="paragraph">
<p>In order to comply with the existing RFC, name compression should not
be suggested.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
<div id="footer">
    <div id="footer-text">
       <a href="https://gris8.github.io/betterfc" style="color:yellow">BetteRFC</a>
       document v1.0 created with
       <a href="https://www.asciidoctor.org" style="color:yellow">Asciidoctor</a>
       v2.0.11.dev
    </div>
</div>
</body>
</html>